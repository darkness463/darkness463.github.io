[{"title":"Android多开检测的另一个思路","date":"2018-09-30T09:42:17.000Z","path":"2018/09/30/Android-Virtual-Check-Plus/","text":"之前写了篇检测多开的文章后，经过几个月的时间，基本上都已经被各多开软件绕过了。最近无意中发现了一些新特征，在特定环境下可以用来检测多开环境，特此来分享一下。 起因某次在多开环境下运行demo，发现动态库加载失败了，错误信息如下： 1234java.lang.UnsatisfiedLinkError: dlopen failed: \"/data/app/【手动打码】/lib/arm64/【手动打码】.so\" is 64-bit instead of 32-bit at java.lang.Runtime.loadLibrary0(Runtime.java:1016) at java.lang.System.loadLibrary(System.java:1660) ... 省略 这个错误没什么好多说的，很明显，动态库是64位的而App运行在32位下，因此加载失败了。其实之前也看到过类似的现象，本应在64位下运行的App到多开环境下就变为32位环境了，只是之前并没有去深究，这次遇到后仔细想了一下，在某些情况下可以用来检测多开环境。 解释对于64位的手机，会启动2个zygote，zygote和zygote64。 12root 670 1 4359784 27292 poll_schedule_timeout 7f7b47058c S zygote64root 671 1 1696576 11120 poll_schedule_timeout eb823684 S zygote 以64位运行的App将由zygote64 fork而来，而以32位运行的App将由zygote fork出来。可以从下面的代码看出来，ZygoteProcess.java中，startViaZygote方法会通过openZygoteSocketIfNeeded方法选择合适的zygote。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] extraArgs) throws ZygoteStartFailedEx &#123; // 省略... synchronized (mLock) &#123; return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125;@GuardedBy(\"mLock\")private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; Preconditions.checkState(Thread.holdsLock(mLock), \"ZygoteProcess lock not held\"); if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; primaryZygoteState = ZygoteState.connect(mSocket); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(mSecondarySocket); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 那么如何确定App是以64位还是以32位运行呢？这就取决于动态库，如果只有32位的动态库（armeabi、armeabi-v7a），那么就会以32位运行，如果有64位的动态库（arm64-v8a），那么就以64位运行，不存在动态库则默认以64位运行。 如何证明？我们写3个demo来实际看一下。 demo1: 包名top.darkness463.whichzygote，不加动态库。 demo2: 包名top.darkness463.zygote32，加一个armeabi动态库。 demo3: 包名top.darkness463.zygote64，加armeabi和arm64-v8a动态库。 12345root 670 1 4359784 27692 poll_schedule_timeout 7f7b47058c S zygote64root 671 1 1696576 11416 poll_schedule_timeout eb823684 S zygoteu0_a177 9878 670 4456080 63412 SyS_epoll_wait 7f7b47046c S top.darkness463.whichzygoteu0_a180 13690 671 1791700 58664 SyS_epoll_wait eb8234ac S top.darkness463.zygote32u0_a179 13871 670 4456524 64716 SyS_epoll_wait 7f7b47046c S top.darkness463.zygote64 可以看到，demo1和demo3的父进程是zygote64，而demo2的父进程是zygote。 那么为何在多开环境下会出现动态库加载失败的情况呢？原因就在于我那个demo有arm64-v8a的动态库，在安装时，系统会把该64位动态库拷到/data/app/【包名】/lib/arm64/下，然后那款多开软件只有32位的动态库，因此是以32位运行的，此时去/data/app/【包名】/lib/arm64/路径下加载64位的动态库必然导致失败。 打开思路的话，这也可以是一种检测多开环境的方式。 局限性其实与其说这是检测多开的方法，倒不如说这是多开软件的bug。看了几款排名靠前的多开软件，都只有32位的动态库，但它们完全可以加上64位动态库来避免这个问题。 另外，为了减小apk的体积，绝大多数App只会添加armeabi平台，而不会添加arm64-v8a平台的动态库，所以这种检测方法在很多App上本身就是不成立的。 补遗之前那篇文章提到过一个通过/proc/self/maps来检测多开的方式，当时提到这个方法的缺点是需要收集所有多开App的包名，但真正搞事的人很可能不会拿市面上的多开软件来作恶，他们可能利用开源的多开软件改成乱七八糟的包名，之前我甚至见过命名成com.tencent.qqlite来进行伪装的。之后我又做了一些工作，也和大家分享一下。 思路还是从/proc/self/maps中的动态库出发。在这里直接给出结论了不再详细讨论了。 /proc/self/maps中出现包含 /vbox/data/、 /shadow/data/、 /virtual/data/的动态库，则运行在多开环境下。主要是因为很多多开软件都是基于开源或者抄来抄去的，所有目录名无外乎这么几种，但不排除会有多开软件修改掉名字的情况。 从/proc/self/maps加载的动态库路径我们可以解析到包名，如果自己的App并不会加载其他App的动态库（第三方登录可能会把其他App的动态库加载进去）的话，出现非自己包名的动态库可能疑似运行在多开环境下。服务端可以建立一套自动解析包名 + 添加到黑名单的流程。","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.darkness463.top/tags/Android/"}]},{"title":"基于mongoose的C++ Http Server的“坑”与“坑”","date":"2018-07-25T09:23:07.000Z","path":"2018/07/25/cpp-http-server-mongoose/","text":"最近有个奇葩的需求，需要用C++去实现一个Http Server。用Java或者其他语言去实现Http Server是一件很简单的事，但用C++去实现我就闻所未闻了（当然主要是我也没写过C++嘛）。于是去搜索了一把，不少人推荐mongoose，在实际使用中遇到了不少的坑。 使用方式使用mongoose只需要将mongoose.h和mongoose.c引入即可。下面通过几个简单的例子了解一下mongoose的使用及工作方式。 简单的Web Server这是官方给的示例。代码如下： 1234567891011121314151617181920212223242526272829303132333435#include \"mongoose.h\"static const char *s_http_port = \"8000\";static struct mg_serve_http_opts s_http_server_opts;static void ev_handler(struct mg_connection *nc, int ev, void *p) &#123; if (ev == MG_EV_HTTP_REQUEST) &#123; mg_serve_http(nc, (struct http_message *) p, s_http_server_opts); &#125;&#125;int main(void) &#123; struct mg_mgr mgr; struct mg_connection *nc; mg_mgr_init(&amp;mgr, NULL); printf(\"Starting web server on port %s\\n\", s_http_port); nc = mg_bind(&amp;mgr, s_http_port, ev_handler); if (nc == NULL) &#123; printf(\"Failed to create listener\\n\"); return 1; &#125; // Set up HTTP server parameters mg_set_protocol_http_websocket(nc); s_http_server_opts.document_root = \".\"; // Serve current directory s_http_server_opts.enable_directory_listing = \"yes\"; for (;;) &#123; mg_mgr_poll(&amp;mgr, 1000); &#125; mg_mgr_free(&amp;mgr); return 0;&#125; 其中有几个关键的结构体。mg_mgr: 用于管理连接、事件等的Manager。mg_connection: 单个连接，保存了连接信息。 从官方给的例子我们可以了解主要用法步骤： 调用mg_mgr_init进行初始化。 调用mg_bind，第2个参数为需要监听的端口号，第3个参数为处理请求的handler。 调用mg_set_protocol_http_websocket将上一步返回的mg_connection与内建的http handler绑定。这样我们的handler才能收到http事件。 通过一直调用mg_mgr_poll接收请求。 接下来我们看一下例子中的handler。12345static void ev_handler(struct mg_connection *nc, int ev, void *p) &#123; if (ev == MG_EV_HTTP_REQUEST) &#123; mg_serve_http(nc, (struct http_message *) p, s_http_server_opts); &#125;&#125; handler有3个参数，第1个参数是当前连接的mg_connection结构体，第2个参数是事件类型，第3个参数为事件的数据。 常用事件类型包含以下几种： MG_EV_ACCEPT: 新连接被接受。 MG_EV_HTTP_REQUEST: 收到http请求，此时第3个参数可以将其强转为http_message结构体使用，包含了method、header、body等等信息。 MG_EV_CLOSE: 连接关闭 例子中在收到MG_EV_HTTP_REQUEST事件时，调用了mg_serve_http，该方法会根据设置的根路径寻找html等资源。 RESTful Server这个例子也是来自于官方。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include \"mongoose.h\"static const char *s_http_port = \"8000\";static struct mg_serve_http_opts s_http_server_opts;static void handle_sum_call(struct mg_connection *nc, struct http_message *hm) &#123; char n1[100], n2[100]; double result; /* Get form variables */ mg_get_http_var(&amp;hm-&gt;body, \"n1\", n1, sizeof(n1)); mg_get_http_var(&amp;hm-&gt;body, \"n2\", n2, sizeof(n2)); /* Send headers */ mg_printf(nc, \"%s\", \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"); /* Compute the result and send it back as a JSON object */ result = strtod(n1, NULL) + strtod(n2, NULL); mg_printf_http_chunk(nc, \"&#123; \\\"result\\\": %lf &#125;\", result); mg_send_http_chunk(nc, \"\", 0); /* Send empty chunk, the end of response */&#125;static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) &#123; struct http_message *hm = (struct http_message *) ev_data; switch (ev) &#123; case MG_EV_HTTP_REQUEST: if (mg_vcmp(&amp;hm-&gt;uri, \"/api/v1/sum\") == 0) &#123; handle_sum_call(nc, hm); /* Handle RESTful call */ &#125; else if (mg_vcmp(&amp;hm-&gt;uri, \"/printcontent\") == 0) &#123; char buf[100] = &#123;0&#125;; memcpy(buf, hm-&gt;body.p, sizeof(buf) - 1 &lt; hm-&gt;body.len ? sizeof(buf) - 1 : hm-&gt;body.len); printf(\"%s\\n\", buf); &#125; else &#123; mg_serve_http(nc, hm, s_http_server_opts); /* Serve static content */ &#125; break; default: break; &#125;&#125;int main(int argc, char *argv[]) &#123; struct mg_mgr mgr; struct mg_connection *nc; struct mg_bind_opts bind_opts; int i; char *cp; const char *err_str;#if MG_ENABLE_SSL const char *ssl_cert = NULL;#endif mg_mgr_init(&amp;mgr, NULL); /* Use current binary directory as document root */ if (argc &gt; 0 &amp;&amp; ((cp = strrchr(argv[0], DIRSEP)) != NULL)) &#123; *cp = '\\0'; s_http_server_opts.document_root = argv[0]; &#125; /* Process command line options to customize HTTP server */ // 省略这部分代码 /* Set HTTP server options */ memset(&amp;bind_opts, 0, sizeof(bind_opts)); bind_opts.error_string = &amp;err_str;#if MG_ENABLE_SSL if (ssl_cert != NULL) &#123; bind_opts.ssl_cert = ssl_cert; &#125;#endif nc = mg_bind_opt(&amp;mgr, s_http_port, ev_handler, bind_opts); if (nc == NULL) &#123; fprintf(stderr, \"Error starting server on port %s: %s\\n\", s_http_port, *bind_opts.error_string); exit(1); &#125; mg_set_protocol_http_websocket(nc); s_http_server_opts.enable_directory_listing = \"yes\"; printf(\"Starting RESTful server on port %s, serving %s\\n\", s_http_port, s_http_server_opts.document_root); for (;;) &#123; mg_mgr_poll(&amp;mgr, 1000); &#125; mg_mgr_free(&amp;mgr); return 0;&#125; 主要区别在于处理MG_EV_HTTP_REQUEST时，根据请求的uri的不同进行不同的处理。示例中请求/api/v1/sum时，调用了handle_sum_call进行处理。 从示例的handle_sum_call方法我们可以了解返回结果基本步骤。 根据业务逻辑得到需要返回的字符串。 调用mg_printf(nc, &quot;%s&quot;, &quot;HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n&quot;);回写headers。 调用mg_printf_http_chunk(nc, result);回写response，其中result即第1步得到的要返回的字符串。 调用mg_send_http_chunk(nc, &quot;&quot;, 0);作为结束。 请求信息的获取处理具体业务时，我们可能需要根据请求的header、method、body等进行相应的处理。前文提到我们在收到MG_EV_HTTP_REQUEST类型的回调时，可以将第3个参数转为http_message结构体，其定义如下，可以结合官方的注释了解其含义。 123456789101112131415161718192021222324252627struct http_message &#123; struct mg_str message; /* Whole message: request line + headers + body */ struct mg_str body; /* Message body. 0-length for requests with no body */ /* HTTP Request line (or HTTP response line) */ struct mg_str method; /* \"GET\" */ struct mg_str uri; /* \"/my_file.html\" */ struct mg_str proto; /* \"HTTP/1.1\" -- for both request and response */ /* For responses, code and response status message are set */ int resp_code; struct mg_str resp_status_msg; /* * Query-string part of the URI. For example, for HTTP request * GET /foo/bar?param1=val1&amp;param2=val2 * | uri | query_string | * * Note that question mark character doesn't belong neither to the uri, * nor to the query_string */ struct mg_str query_string; /* Headers */ struct mg_str header_names[MG_MAX_HTTP_HEADERS]; struct mg_str header_values[MG_MAX_HTTP_HEADERS];&#125;; 其中每一个属性都是mg_str结构体，其定义如下。 1234struct mg_str &#123; const char *p; /* Memory chunk pointer */ size_t len; /* Memory chunk length */&#125;; 可以看出，mg_str实际就是存了起始地址和长度，所有我们从相应地址开始截取指定长度就是对于的属性内容。我们可以用类似下面这种方式获取相应属性： 123std::string uri = std::string(http_req-&gt;uri.p, http_req-&gt;uri.len);std::string body = std::string(http_req-&gt;body.p, http_req-&gt;body.len);std::string method = std::string(http_req-&gt;method.p, http_req-&gt;method.len); headers的获取类似，header的key和value分别存放在header_names和header_values2个数组中，数组的长度MG_MAX_HTTP_HEADERS默认值为40，因此最大只支持40个header，当然我们可以自行修改该值。 多线程前文已经介绍了mongoose的简单使用了，但都是单线程的方式，QPS必然很难上去。mongoose也能支持1个IO线程、N个工作线程的模式。我们还是先来看一下官方示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include \"mongoose.h\"static sig_atomic_t s_received_signal = 0;static const char *s_http_port = \"8000\";static const int s_num_worker_threads = 5;static unsigned long s_next_id = 0;static void signal_handler(int sig_num) &#123; signal(sig_num, signal_handler); s_received_signal = sig_num;&#125;static struct mg_serve_http_opts s_http_server_opts;static sock_t sock[2];// This info is passed to the worker thread// 用于IO线程向工作线程发送请求struct work_request &#123; unsigned long conn_id; // needed to identify the connection where to send the reply // optionally, more data that could be required by worker &#125;;// This info is passed by the worker thread to mg_broadcast// 用于工作线程向IO线程返回结果struct work_result &#123; unsigned long conn_id; int sleep_time;&#125;;// 运行在IO线程，用于回写结果static void on_work_complete(struct mg_connection *nc, int ev, void *ev_data) &#123; (void) ev; char s[32]; struct mg_connection *c; for (c = mg_next(nc-&gt;mgr, NULL); c != NULL; c = mg_next(nc-&gt;mgr, c)) &#123; if (c-&gt;user_data != NULL) &#123; struct work_result *res = (struct work_result *)ev_data; if ((unsigned long)c-&gt;user_data == res-&gt;conn_id) &#123; sprintf(s, \"conn_id:%lu sleep:%d\", res-&gt;conn_id, res-&gt;sleep_time); mg_send_head(c, 200, strlen(s), \"Content-Type: text/plain\"); mg_printf(c, \"%s\", s); &#125; &#125; &#125;&#125;// 工作线程void *worker_thread_proc(void *param) &#123; struct mg_mgr *mgr = (struct mg_mgr *) param; struct work_request req = &#123;0&#125;; while (s_received_signal == 0) &#123; if (read(sock[1], &amp;req, sizeof(req)) &lt; 0) perror(\"Reading worker sock\"); int r = rand() % 10; sleep(r); struct work_result res = &#123;req.conn_id, r&#125;; mg_broadcast(mgr, on_work_complete, (void *)&amp;res, sizeof(res)); &#125; return NULL;&#125;static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) &#123; (void) nc; (void) ev_data; switch (ev) &#123; case MG_EV_ACCEPT: // 给连接设置一个id，用于后面IO线程回写结果找到对应的id回写。 nc-&gt;user_data = (void *)++s_next_id; break; case MG_EV_HTTP_REQUEST: &#123; struct work_request req = &#123;(unsigned long)nc-&gt;user_data&#125;; if (write(sock[0], &amp;req, sizeof(req)) &lt; 0) perror(\"Writing worker sock\"); break; &#125; case MG_EV_CLOSE: &#123; if (nc-&gt;user_data) nc-&gt;user_data = NULL; &#125; &#125;&#125;int main(void) &#123; struct mg_mgr mgr; struct mg_connection *nc; int i;// 起一对socket，用于IO线程向工作线程发送请求 if (mg_socketpair(sock, SOCK_STREAM) == 0) &#123; perror(\"Opening socket pair\"); exit(1); &#125; signal(SIGTERM, signal_handler); signal(SIGINT, signal_handler); mg_mgr_init(&amp;mgr, NULL); nc = mg_bind(&amp;mgr, s_http_port, ev_handler); if (nc == NULL) &#123; printf(\"Failed to create listener\\n\"); return 1; &#125; mg_set_protocol_http_websocket(nc); s_http_server_opts.document_root = \".\"; // Serve current directory s_http_server_opts.enable_directory_listing = \"no\"; for (i = 0; i &lt; s_num_worker_threads; i++) &#123; mg_start_thread(worker_thread_proc, &amp;mgr); &#125; printf(\"Started on port %s\\n\", s_http_port); while (s_received_signal == 0) &#123; mg_mgr_poll(&amp;mgr, 200); &#125; mg_mgr_free(&amp;mgr); closesocket(sock[0]); closesocket(sock[1]); return 0;&#125; 简单来说，流程是IO线程收到请求后，将请求通过socket发往工作线程，工作线程处理完后，通过mg_broadcast方法返回IO线程，mongoose内部也有一对socket用于工作线程向IO线程通信，IO线程收到后向对应的连接回写结果。 我们一个一个关键点来看。 socket1234if (mg_socketpair(sock, SOCK_STREAM) == 0) &#123; perror(\"Opening socket pair\"); exit(1);&#125; 通过调用mg_socketpair方法开启一对socket，如前文所述，这对socket是用于IO线程向工作线程发送请求的。而工作线程向IO线程返回结果的socket不需要我们操心，mongoose帮我们实现了。示例中定义了work_request和work_result2个结构体用于传输请求和结果，我们可以根据业务需要修改这2个结构体，但需要注意序列化的问题。 另外这里有个隐藏的坑。mongoose帮我们实现的socket利用了其定义的ctl_msg结构体进行传输。其定义如下： 1234struct ctl_msg &#123; mg_event_handler_t callback; char message[MG_CTL_MSG_MESSAGE_SIZE];&#125;; 其中MG_CTL_MSG_MESSAGE_SIZE默认值是8192，因此如果你的返回结果超过8k会有问题，需要将该值调大。 如果不想用socket从IO线程向工作线程发请求的话，我们也可以使用队列之类的，IO线程将请求往队列扔，工作线程一直从队列读请求。这里就不写具体实现了。 工作线程123for (i = 0; i &lt; s_num_worker_threads; i++) &#123; mg_start_thread(worker_thread_proc, &amp;mgr);&#125; 示例中这部分代码即开启工作线程，我们可以根据自己的需要启动任意数量的工作线程。需要注意的是我们要将MG_ENABLE_THREADS的值改为1，否则mg_start_thread是无法调用的。 示例中的工作线程的实现如下： 1234567891011121314void *worker_thread_proc(void *param) &#123; struct mg_mgr *mgr = (struct mg_mgr *) param; struct work_request req = &#123;0&#125;; while (s_received_signal == 0) &#123; if (read(sock[1], &amp;req, sizeof(req)) &lt; 0) perror(\"Reading worker sock\"); int r = rand() % 10; sleep(r); struct work_result res = &#123;req.conn_id, r&#125;; mg_broadcast(mgr, on_work_complete, (void *)&amp;res, sizeof(res)); &#125; return NULL;&#125; 首先通过read把work_request读出来，处理完后调用mg_broadcast将work_result返回IO线程，其中on_work_complete是返回IO线程后需要执行的方法。上节已经提到了，需要注意一下返回长度的问题。 IO线程（接收请求）1234567891011121314151617181920static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) &#123; (void) nc; (void) ev_data; switch (ev) &#123; case MG_EV_ACCEPT: nc-&gt;user_data = (void *)++s_next_id; break; case MG_EV_HTTP_REQUEST: &#123; struct work_request req = &#123;(unsigned long)nc-&gt;user_data&#125;; if (write(sock[0], &amp;req, sizeof(req)) &lt; 0) perror(\"Writing worker sock\"); break; &#125; case MG_EV_CLOSE: &#123; if (nc-&gt;user_data) nc-&gt;user_data = NULL; &#125; &#125;&#125; 在MG_EV_ACCEPT事件时，为mg_connection的user_data赋一个id，之后需要根据这个id确定向哪个连接回写结果。MG_EV_CLOSE事件时将该id置空。 而在MG_EV_HTTP_REQUEST时，通过write方法将封装的work_request向socket写。这样便能被上一节中的工作线程从socket中读到。 IO线程（返回结果）123456789101112131415static void on_work_complete(struct mg_connection *nc, int ev, void *ev_data) &#123; (void) ev; char s[32]; struct mg_connection *c; for (c = mg_next(nc-&gt;mgr, NULL); c != NULL; c = mg_next(nc-&gt;mgr, c)) &#123; if (c-&gt;user_data != NULL) &#123; struct work_result *res = (struct work_result *)ev_data; if ((unsigned long)c-&gt;user_data == res-&gt;conn_id) &#123; sprintf(s, \"conn_id:%lu sleep:%d\", res-&gt;conn_id, res-&gt;sleep_time); mg_send_head(c, 200, strlen(s), \"Content-Type: text/plain\"); mg_printf(c, \"%s\", s); &#125; &#125; &#125;&#125; 这里的逻辑是遍历所有的连接，找出id相同的连接（即上一节提到的MG_EV_ACCEPT事件时设置的id），然后向改连接回写结果。 这里示例的实现我觉得有点问题，我们看一下mongoose中是如何回调on_work_complete方法的。前文提到mongoose中也有一对socket，用于工作线程向IO线程发送结果，结果是在mg_mgr_handle_ctl_sock方法中取出来的，代码如下： 123456789101112131415static void mg_mgr_handle_ctl_sock(struct mg_mgr *mgr) &#123; struct ctl_msg ctl_msg; int len = (int) MG_RECV_FUNC(mgr-&gt;ctl[1], (char *) &amp;ctl_msg, sizeof(ctl_msg), 0); size_t dummy = MG_SEND_FUNC(mgr-&gt;ctl[1], ctl_msg.message, 1, 0); DBG((\"read %d from ctl socket\", len)); (void) dummy; /* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509 */ if (len &gt;= (int) sizeof(ctl_msg.callback) &amp;&amp; ctl_msg.callback != NULL) &#123; struct mg_connection *nc; for (nc = mg_next(mgr, NULL); nc != NULL; nc = mg_next(mgr, nc)) &#123; ctl_msg.callback(nc, MG_EV_POLL, ctl_msg.message MG_UD_ARG(nc-&gt;user_data)); &#125; &#125;&#125; 可以清楚地看到，mongoose已经将所有的连接遍历一次了，并且会将每个连接当参数执行回调的方法（即ctl_msg.callback(nc, MG_EV_POLL, ctl_msg.message MG_UD_ARG(nc-&gt;user_data));）。所有我理解在on_work_complete中我们没必要再遍历一次了，只需要判断传过来的mg_connection是不是我们需要的那个连接，对正确的那个连接回写即可。 性能在16核 16G内存的机器上进行了一下压测。同样都以20个并发压（恕我直言，并发太高这个框架根本扛不住）。压了3个不同的版本，这三个版本逻辑基本是一致的。123版本一： Go + C++版本。Go实现Http Server，Thrift调用C++逻辑代码。版本二： C++版本。C++实现Http Server（基于mongoose），逻辑部分和版本一一样，因为整合成了一个程序，所以直接调用逻辑部分的方法。版本三： Java版本。基于Spring Boot。 在20的并发下，版本一最大QPS 3500左右，不过此时平均耗时已经增加到了30~40ms。版本二最大QPS 2000左右，平均耗时6ms。版本三最大QPS 5000~5500，平均耗时4ms。 总结 mongoose并不算很成熟，性能上也不怎么样。 如果真的需要使用，最好再进行一层封装。可以参考这位同学的实现。 C++用于应用层不仅开发起来费时，得到的好处似乎也有限，可能是我太年轻？","tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.darkness463.top/tags/Cpp/"}]},{"title":"聊聊Xposed检测","date":"2018-06-20T07:57:49.000Z","path":"2018/06/20/Xposed-Check/","text":"这两天看到有部分人称微信大规模封号，主要被封的是Xposed和各类微信插件的使用者，部分人说自己只是安装了Xposed，但并未使用微信相关的任何插件也被封了。由此有人开始说微信侵犯用户隐私，随意扫描用户的手机等等。 本人一直是Xposed的使用者，主要是用来使用自己写的扒Android8.1上“吉字节”等单位改回“GB”的插件。另外也有使用修改微信UI以及防撤回的与微信相关的插件，但并未受到此次封号的影响。普通用户不太清楚开发方面的事，以为检测Xposed框架是件很复杂的事，今天就来聊聊Xposed的简单检测方法。 检测Xposed重写了zygote，zygote启动时会加载Xposed相关组件，因此由zygote孵化出来的每个进程都会有Xposed的相关代码。根据这一原理，我们可以通过以下几种方式检测。 Xposed InstallerXposed利用Xposed Installer这一App安装Xposed和管理模块，其包名为de.robv.android.xposed.installer，检测这一包名是最简单直观的对Xposed检测的方法。 堆栈信息抛出一个异常并捕获，将堆栈信息打印出来。 12345678// .....省略部分at android.os.Handler.dispatchMessage(Handler.java:106)at android.os.Looper.loop(Looper.java:164)at android.app.ActivityThread.main(ActivityThread.java:6494)at java.lang.reflect.Method.invoke(Native Method)at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:440)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:108) 可以看到每个App是先执行的XposedBridge.jar的main方法，之后再调用的Zygote的main方法。通过检测堆栈中是否包含Xposed等字样即可知道是否安装了Xposed。 mapsXposed的组件需要被加载，必然在内存空间留下痕迹。通过遍历/proc/&lt;pid&gt;/maps（/proc/self/maps）的内容可以发现如下内容。因此也可以据此来判断。 17de6c41000-7de6c42000 r--s 00019000 b3:18 139265 /system/framework/XposedBridge.jar 更精准的检测以上方法只能检测用户是否安装使用了Xposed，这是一个风险点，但我们并不能因为用户使用了Xposed就将其封禁。通过Xposed的实现方式，我们可以采取更精准的方式去检测。 在de.robv.android.xposed.XposedBridge中有一个disableHooks字段用于标记对于当前应用是否要进行hook。通过获取这个字段的值就可以知道是否在我们App上启用hook了，甚至可以通过将其设置为true停掉Xposed。 123456Field disableHooksFiled = ClassLoader.getSystemClassLoader() .loadClass(\"de.robv.android.xposed.XposedBridge\") .getDeclaredField(\"disableHooks\");disableHooksFiled.setAccessible(true);Object enable = disableHooksFiled.get(null); // 当前状态disableHooksFiled.set(null, true); // 设置为关闭 另一个更为精准的方式见这篇文章，Xposed将需要hook的字段、方法、构造函数等缓存在了几个HashMap中，通过遍历这几个看是否有与自己相关的内容就可知道自己是否有被hook了，具体的原理和方法可以看一下这篇文章。 反检测与反反检测上面提到的那些检测方法实际上都可以被绕过的，hook掉调用的那些检测方法并返回虚假的信息就可以轻松绕过。例如上文提到检测maps文件，那么我们可以需要类似下面这样的伪代码遍历maps文件的每一行并判断是否包含Xposed的相关组件。 1line.contains(\"Xposed\") 那么可以hookString.contains方法，如果发现你想判断的内容包含Xposed等关键字就直接返回false即可。 面对这些反检测的手段，第一我们可以增加检测的维度，加大绕过检测的难度，从Java层和C层进行多方面的检测。第二我们可以设置一些蜜罐，例如面对上面这种反检测的手段，如果我们调用&quot;Xposed&quot;.contains(&quot;Xposed&quot;)的返回值是false，那必然说明其使用了这种反检测手段。 结语攻防真的很无聊。","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.darkness463.top/tags/Android/"},{"name":"Xposed","slug":"Xposed","permalink":"https://blog.darkness463.top/tags/Xposed/"}]},{"title":"Android多开/分身检测","date":"2018-05-04T08:59:34.000Z","path":"2018/05/04/Android-Virtual-Check/","text":"多开/分身原本用于方便有多个微信/QQ解决同时登录的问题，但近来年被各种黑产所利用，多见于薅羊毛，部分多开App甚至提供了篡改功能。对于普通用户根本不会有多开的需求的App，一旦检测到当前运行在多开环境下，有理由限制该用户的后续行为。 在尝试了目前市面上多款多开App后，总结了几种检测方案。 多开原理目前市面上的多开App的原理类似，都是以新进程运行被多开的App，并hook各类系统函数，使被多开的App认为自己是一个正常的App在运行。 从形式上来说多开App有2种形式，一种是从多开App中直接加载被多开的App，如平行空间、VirtualApp等，另一种是让用户新安装一个App，但这个App本质上就是一个壳，用来加载被多开的App，其原理和前一种是一样的，市面上多开分身这款App是用的这种形式，用户每分身一个App需新安装一个包名为dkmodel.xxx.xxx的App。 检测方案检测files目录路径我们知道App的私有目录是/data/data/包名/或/data/user/用户号/包名，通过Context.getFilesDir()方法可以拿到私有目录下的files目录。在多开环境下，获取到目录会变为/data/data/多开App的包名/xxxxxxxx或/data/user/用户号/多开App的包名/xxxxxxxx。 举个例子，在我手机上，正常使用App上面的代码获取到的路径为/data/user/0/top.darkness463.virtualcheck/files。在多开分身的多开环境下，路径为/data/user/0/dkmodel.zom.rxo/virtual/data/user/0/top.darkness463.virtualcheck/files。 当然，多开软件是可以hook处理让你拿到正常的目录，但截至写这篇文章为止，市面上大部分多开App没有绕过这项检测，仅有360家的分身大师可以绕过。 ps检测这种检测方法见这篇文章。这里就不重复了，我简单说一下原理。 我们先通过执行ps命令并以自己的uid进行过滤，得到类似下面的结果。 1234567// 正常情况下u0_a148 8162 423 1806036 56368 SyS_epoll+ 0 S top.darkness463.virtualcheck// 多开环境下u0_a155 19752 422 4437612 62752 SyS_epoll+ 0 S top.darkness463.virtualchecku0_a155 19758 422 564234 54356 SyS_epoll+ 0 S com.lbe.parallelu0_a155 19747 422 734562 24542 SyS_epoll+ 0 S com.lbe.parallel:mdserver 可以看到在多开环境下，会获取到自己的包名和多开App的包名这2个包名，通过这些包名去/data/data/下找会找到2个目录，而正常情况下只能在/data/data/下找到自己的App的目录。 具体的实现原文已经贴了，这里也不重复了。目前未发现有多开App能绕过该项检测，但在Google Pixel Android 8.0下执行ps获取不到进程信息，在Android 8.1的类AOSP rom下都能正常获取，不知道那个手机什么情况。 应用列表检测这里的应用列表检测不是指简单的遍历应用列表判断是不是安装了多开App，我们并不阻止用户安装多开App并多开其他App，我们只是不希望用户多开我们自己的App，因此不能检测到用户安装了多开App就把他干掉。 多开App都会对context.getPackageName()进行处理，让这个方法返回原始App的包名，因此在被多开的App看来，多开App的包名和原始的那个App的包名一样，因此在多开环境下遍历应用列表时会发现包名等于原始App的包名的应用会有两个。 代码如下。只对部分多开App有效，例如360的分身大师，不少多开App会绕过这项检测。 123456789101112131415161718private boolean checkPkg(Context context) &#123; try &#123; if (context == null) &#123; return false; &#125; int count = 0; String packageName = context.getPackageName(); PackageManager pm = context.getPackageManager(); List&lt;PackageInfo&gt; pkgs = pm.getInstalledPackages(0); for (PackageInfo info : pkgs) &#123; if (packageName.equals(info.packageName)) &#123; count++; &#125; &#125; return count &gt; 1; &#125; catch (Exception ignore) &#123;&#125; return false;&#125; maps检测读取/proc/self/maps，多开App会加载一些自己的so到内存空间，举个例子，360的分身大师加载了其目录下的某个so，/data/app/com.qihoo.magic-gdEsg8KRAuJy0MuY18BlqQ==/lib/arm/libbreakpad-jni-1.5.so，通过对各种多开App的包名的匹配，如果maps中有多开App的包名的东西，那么当前就是运行在多开环境下。 目前没有发现多开App绕过该项检测，但缺点是需要收集所有多开App的包名，一旦多开App改个包名就失效了。 伪代码如下。 123456789101112131415161718192021222324252627Set&lt;String&gt; virtualPkgs; // 多开App包名列表private boolean check() &#123; BufferedReader bufr = null; try &#123; bufr = new BufferedReader(new FileReader(\"/proc/self/maps\")); String line; while ((line = bufr.readLine()) != null) &#123; for (String pkg : virtualPkgs) &#123; if (line.contains(pkg)) &#123; return true; &#125; &#125; &#125; &#125; catch (Exception ignore) &#123; &#125; finally &#123; if (bufr != null) &#123; try &#123; bufr.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; return false;&#125; 总结这些方法有的已经被部分多开App绕过了，有的暂时还未绕过，建议所有的检测都加上，而且可以Java层和C层都进行检测。当然，与黑产斗争的道路我们永远处于劣势。","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.darkness463.top/tags/Android/"}]},{"title":"【All in One】Once","date":"2018-04-10T13:33:13.000Z","path":"2018/04/10/All-in-One-Once/","text":"Once是一个开源的用于管理一些只需要进行一次（或几次）的操作的库。比如说只显示一次引导页，每个版本只显示一次更新说明等等。 使用方式添加依赖123dependencies &#123; compile &apos;com.jonathanfinerty.once:once:1.2.2&apos;&#125; 初始化1Once.initialise(this); 使用检测某项操作是否已进行： 12345678String showWhatsNew = \"showWhatsNewTag\";// 检测是否需要进行操作if (!Once.beenDone(Once.THIS_APP_VERSION, showWhatsNew)) &#123; startActivity(new Intent(this, WhatsNewActivity.class)); // 完成后进行标记 Once.markDone(showWhatsNew);&#125; Once支持3种尺度： 123THIS_APP_INSTALL: 安装到卸载前，例如引导页只出现一次，升级也不重复出现。THIS_APP_VERSION: 当前版本，例如更新说明，一个版本出现一次。THIS_APP_SESSION: 本次使用。 此外，也支持如果时间，在设定的时间内进行一次操作。 1if (!Once.beenDone(TimeUnit.HOURS, 1, phonedHome) &#123; ... &#125; Once还支持将某件事标记为”to do”，之后检查是否需要做某项操作。Once给我们举了个例子，有时你想在用户看到基础功能后，在MainActivity中显示一些高级功能。 12345678910111213// in the basic functionality activityOnce.toDo(Once.THIS_APP_INSTALL, \"show feature onboarding\");...// back in the home activityif (Once.needToDo(showAppTour)) &#123; // do some operations ... // after task has been done, mark it as done as normal Once.markDone(showAppTour);&#125; 除了进行一次，Once也支持第N次后进行某些操作。例如，在用户使用3次App后弹出让用户评分的dialog。 12345678910// Once again in the basic functionality activityOnce.markDone(\"action\");if (Once.beenDone(\"action\", Amount.exactly(3))) &#123; showRateTheAppDialog();&#125;// 支持下面这三种Amount.exactly(int x) // 第x次时Amount.lessThan(int x) // 小于x次时Amount.moreThan(int x) // 大于x次时 具体实现Once的功能很简单，如果不使用Once而是自己实现的话，我们必然会用SharedPreferences去记录是否进行过某些操作，Once的实现也是类似的。 PersistedMap和PersistedSet这两个类是Once中保存和处理SharedPreferences。PersistedMap对应名为PersistedMapTagLastSeenMap的sp，用于保存那些被markDone的tag的时间戳，sp中保存的key为tag，value为时间戳拼成的字符串，以逗号分隔各时间戳，在PersistedMap中保存在Map&lt;String, List&lt;Long&gt;&gt; map对象中，map的key为tag，List即为由时间戳字符串还原成的list。PersistedSet对应名为PersistedSetToDoSet的sp，用于保存被标记为todo的tag，Android3.0以上的版本直接已Set的形式保存在sp中，3.0以下以字符串形式保存，用逗号分隔。 PersistedMap和PersistedSet的实现类似，初始化时通过AsyncTask异步去加载各自的SharedPreferences，提供put、remove等方法，调用这些方法会更新内存中的Map/Set，并更新sp。 AsyncSharedPreferenceLoader供PersistedMap和PersistedSet加载SharedPreferences使用。内部实现了一个AsyncTask用于异步加载SharedPreferences，并提供get()方法用于获取加载后的SharedPreferences。 1234567891011121314private final AsyncTask&lt;String, Void, SharedPreferences&gt; asyncTask = new AsyncTask&lt;String, Void, SharedPreferences&gt;() &#123; @Override protected SharedPreferences doInBackground(String... names) &#123; return context.getSharedPreferences(names[0], Context.MODE_PRIVATE); &#125;&#125;;SharedPreferences get() &#123; try &#123; return asyncTask.get(); &#125; catch (InterruptedException | ExecutionException ignored) &#123; return null; &#125;&#125; OnceOnce的主类，提供了Once能实现的所有功能。这里只介绍一些主要方法的实现。 initialise初始化方法。 12345678910111213141516171819public static void initialise(Context context) &#123; // 初始化PersistedMap和PersistedSet tagLastSeenMap = new PersistedMap(context, \"TagLastSeenMap\"); toDoSet = new PersistedSet(context, \"ToDoSet\"); // sessionList用于保存处理THIS_APP_SESSION级别的tag。 if (sessionList == null) &#123; sessionList = new ArrayList&lt;&gt;(); &#125; // 获取lastAppUpdatedTime，用于处理THIS_APP_VERSION级别。 PackageManager packageManager = context.getPackageManager(); try &#123; PackageInfo packageInfo = packageManager.getPackageInfo(context.getPackageName(), 0); lastAppUpdatedTime = packageInfo.lastUpdateTime; &#125; catch (PackageManager.NameNotFoundException ignored) &#123; &#125;&#125; markDone用于记录某个tag对应的操作的完成。会将当前时间戳增加进PersistedMap中，向sessionList中添加该tag，并从PersistedSet中将该tag移除。 12345public static void markDone(String tag) &#123; tagLastSeenMap.put(tag, new Date().getTime()); sessionList.add(tag); toDoSet.remove(tag);&#125; beenDone用于判断某个tag是否已完成。有一系列重载的方法， 1234567891011121314151617// THIS_APP_INSTALL级别，该tag是否满足moreThan(0)。beenDone(String tag);// THIS_APP_INSTALL级别，该tag是否满足传入的numberOfTimes条件。beenDone(String tag, CountChecker numberOfTimes);// 自定义scope，该tag是否满足moreThan(0)。beenDone(@Scope int scope, String tag);// 自定义scope，该tag是否满足传入的numberOfTimes条件。beenDone(@Scope int scope, String tag, CountChecker numberOfTimes);// amount * timeUnit之前至今，该tag是否满足moreThan(0)。beenDone(TimeUnit timeUnit, long amount, String tag);// amount * timeUnit之前至今，该tag是否满足传入的numberOfTimes条件。beenDone(TimeUnit timeUnit, long amount, String tag, CountChecker numberOfTimes);// timeSpanInMillis之前至今，该tag是否满足moreThan(0)。beenDone(long timeSpanInMillis, String tag);// timeSpanInMillis之前至今，该tag是否满足传入的numberOfTimes条件。beenDone(long timeSpanInMillis, String tag, CountChecker numberOfTimes); 前4个方法以scope为维度，最终都会调用到beenDone(@Scope int scope, String tag, CountChecker numberOfTimes)，后4个方法以时间为维度，最终都会调用beenDone(long timeSpanInMillis, String tag, CountChecker numberOfTimes)，我们来看一下这2个方法即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static boolean beenDone(@Scope int scope, String tag, CountChecker numberOfTimes) &#123; // 获取该tag所有的记录。 List&lt;Long&gt; tagSeenDates = tagLastSeenMap.get(tag); if (tagSeenDates.isEmpty()) &#123; return false; &#125; //noinspection SimplifiableIfStatement if (scope == THIS_APP_INSTALL) &#123; // THIS_APP_INSTALL级别，直接和记录的size比较。 return numberOfTimes.check(tagSeenDates.size()); &#125; else if (scope == THIS_APP_SESSION) &#123; // THIS_APP_SESSION级别，和sessionList中该tag的个数比较。 int counter = 0; for (String tagFromList : sessionList) &#123; if (tagFromList.equals(tag)) &#123; counter++; &#125; &#125; return numberOfTimes.check(counter); &#125; else &#123; // THIS_APP_VERSION级别，记录中大于lastAppUpdatedTime的才计算进去。 int counter = 0; for (Long seenDate : tagSeenDates) &#123; if (seenDate &gt; lastAppUpdatedTime) &#123; counter++; &#125; &#125; return numberOfTimes.check(counter); &#125;&#125; public static boolean beenDone(long timeSpanInMillis, String tag, CountChecker numberOfTimes) &#123; List&lt;Long&gt; tagSeenDates = tagLastSeenMap.get(tag); if (tagSeenDates.isEmpty()) &#123; return false; &#125; int counter = 0; for (Long seenDate : tagSeenDates) &#123; // 计算出最小的有效时间 long sinceSinceCheckTime = new Date().getTime() - timeSpanInMillis; // 比较记录的时间和有效时间，比有效时间大的才计入。 if (seenDate &gt; sinceSinceCheckTime) &#123; counter++; &#125; &#125; return numberOfTimes.check(counter);&#125; toDo/needToDotoDo用于标记某个tag “need to do”。有toDo(@Scope int scope, String tag)和toDo(String tag)2个方法。需要注意的是，使用toDo(@Scope int scope, String tag)时，如果该tag之前被markDone过，则仅当传入的scope为THIS_APP_VERSION且该tag上次被markDone的时间在lastAppUpdatedTime之前才会将该tag添加到PersistedSet中。而toDo(String tag)则无论该tag之前有没有被markDone，都会添加到PersistedSet中。needToDo即用于检查PersistedSet中是否存在对应的tag。 总结 Once可以帮我们方便地管理一些操作在什么时候进行。 利用SharedPreferences保存记录。 支持THIS_APP_INSTALL、THIS_APP_VERSION、THIS_APP_SESSION三种级别。利用每次markDone的时间戳实现对三种级别的支持。","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.darkness463.top/tags/Android/"},{"name":"All in One","slug":"All-in-One","permalink":"https://blog.darkness463.top/tags/All-in-One/"},{"name":"Once","slug":"Once","permalink":"https://blog.darkness463.top/tags/Once/"}]},{"title":"Android-ConditionVariable","date":"2018-03-28T02:08:39.000Z","path":"2018/03/28/Android-ConditionVariable/","text":"ConditionVariable是Android提供的用于wait和notify的类，与java的wait()和notify()不同的地方在于ConditionVarible可以根据状态决定是否wait。 提供的方法ConditionVariable有四个方法： 1234567891011121314151617/*** 释放所以block的线程，且将状态设置为open，如果之后不调用close()，则调用block()不会阻塞。*/public void open();/*** 将状态设置为close。之后调用block()将会阻塞。*/public void close();/*** 如果状态不为open，则阻塞当前线程直到调用open()，否则直接返回。*/public void block();/*** 如果状态不为open，则阻塞当前线程直到调用open()或达到timeout时间，否则直接返回。* 如果是因为open而返回，则返回true，如果是因为超市而返回，则返回false。*/public boolean block(long timeout); 实现ConditionVariable的实现非常简单，根据mCondition变量的值决定当前是open还是close状态，mCondition等于true时为open，false时为close。调用block()时，仅在mCondition等于false时才会调用wait()。 总结ConditionVariable简化了wait()和notify()的编写，如果需要根据情况决定是否wait，可以考虑使用ConditionVariable。","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.darkness463.top/tags/Android/"}]},{"title":"废话几句","date":"2018-03-27T15:21:17.000Z","path":"2018/03/27/say-something/","text":"全是废话 当初在Github上搭了这个站之后就几乎没发过什么东西，后来买了一个域名也没有鸟过了。 这两天看到了由yscoder开源的hexo主题hexo-theme-indigo，挺好看的，于是把之前的推倒重来了。 之前的几篇东西受限于当时知识的有限，有一些不太对的地方，但是懒得改了，所以也就不放上来了，只把几篇总结笔记类的改了格式传上来了。 之后多写点东西吧(大概吧)。","tags":[]},{"title":"【总结】Android辅助功能(一)-AccessibilityEvent的分发","date":"2017-04-17T05:41:10.000Z","path":"2017/04/17/accessibility-event/","text":"目前关于辅助功能的使用的文章很多，但鲜有分析其具体实现的，本文基于Andoird 7.1.0_r7源码分析一下辅助事件是怎么分发的，只涉及事件的分发和辅助App的接收，之后有机会再讲一讲获取AccessibilityNodeInfo、进行操作等等的源码流程。文中“目标App”指的是发出辅助事件的App，“辅助App”指的是拥有辅助功能的App。 流程【目标App】 View.sendAccessibilityEvent(int eventType)我们看View的源码可以看到在很多地方调用了sendAccessibilityEvent(int eventType)的方法，例如： 在View获取到焦点时，调用了sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED)； 当View被点击时，调用了sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED) 使用过辅助功能的同学对这些Event应该很熟悉，这些就是我们在写辅助App时定义的想要接收的辅助事件的类型，Android为我们定义了一系列辅助事件，这里举几个比较常用的事件： TYPE_VIEW_CLICKED // 当View被点击时发送此事件。 TYPE_VIEW_LONG_CLICKED // 当View被长按时发送此事件。 TYPE_VIEW_FOCUSED // 当View获取到焦点时发送此事件。 TYPE_WINDOW_STATE_CHANGED // 当Window发生变化时发送此事件。 TYPE_VIEW_SCROLLED // 当View滑动时发送此事件。 所以说，sendAccessibilityEvent(int eventType)就是我们的起点，我们来看一看这个方法。View实现了AccessibilityEventSource接口，这个方法就来自于AccessibilityEventSource接口。 public void sendAccessibilityEvent(int eventType) { if (mAccessibilityDelegate != null) { // AccessibilityDelegate是用来增强辅助功能的，一般情况下不用考虑。 mAccessibilityDelegate.sendAccessibilityEvent(this, eventType); } else { sendAccessibilityEventInternal(eventType); } } 【目标App】 View.sendAccessibilityEventInternal(int eventType) -&gt; View.sendAccessibilityEventUnchecked(AccessibilityEvent event)这2个方法都比较短，就放在一起说了。sendAccessibilityEventInternal(int eventType)会检查当前辅助服务是否开启，至少有一个辅助App被开启了才会返回true。如果当前开启了，会把eventType转成AccessibilityEvent，这就是我们在AccessibilityService中收到的AccessibilityEvent，之后调用了sendAccessibilityEventUnchecked(AccessibilityEvent event)，进而调用了sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)。 public void sendAccessibilityEventInternal(int eventType) { if (AccessibilityManager.getInstance(mContext).isEnabled()) { sendAccessibilityEventUnchecked(AccessibilityEvent.obtain(eventType)); } } public void sendAccessibilityEventUnchecked(AccessibilityEvent event) { if (mAccessibilityDelegate != null) { // AccessibilityDelegate是用来增强辅助功能的，一般情况下不用考虑。 mAccessibilityDelegate.sendAccessibilityEventUnchecked(this, event); } else { sendAccessibilityEventUncheckedInternal(event); } } 【目标App】 View.sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)此时会先判断当前View及所有的Parent是否可见，如果不可见则不会分发当前的AccessibilityEvent。onInitializeAccessibilityEvent(event)做了一些初始化工作，例如给AccessibilityEvent设置source、className、packageName等等信息。 系统定义了一个叫POPULATING_ACCESSIBILITY_EVENT_TYPES的常量，包括了AccessibilityEvent.TYPE_VIEW_CLICKED等等一系列Event，当发送的EventType是这些中的一个时，目标App可以通过重写dispatchPopulateAccessibilityEvent(AccessibilityEvent event)或onPopulateAccessibilityEvent(AccessibilityEvent event)方法对将要发送的AccessibilityEvent进行修改。 之后会调用getParent().requestSendAccessibilityEvent(this, event)发给Parent View去处理。 public void sendAccessibilityEventUncheckedInternal(AccessibilityEvent event) { // 判断View是否可见 if (!isShown()) { return; } // 设置AccessibilityEvent的一些信息 onInitializeAccessibilityEvent(event); if ((event.getEventType() &amp; POPULATING_ACCESSIBILITY_EVENT_TYPES) != 0) { // 目标App可通过此方法修改AccessibilityEvent dispatchPopulateAccessibilityEvent(event); } // In the beginning we called #isShown(), so we know that getParent() is not null. getParent().requestSendAccessibilityEvent(this, event); } private static final int POPULATING_ACCESSIBILITY_EVENT_TYPES = AccessibilityEvent.TYPE_VIEW_CLICKED | AccessibilityEvent.TYPE_VIEW_LONG_CLICKED | AccessibilityEvent.TYPE_VIEW_SELECTED | AccessibilityEvent.TYPE_VIEW_FOCUSED | AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | AccessibilityEvent.TYPE_VIEW_HOVER_ENTER | AccessibilityEvent.TYPE_VIEW_HOVER_EXIT | AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED | AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED | AccessibilityEvent.TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY; 【目标App】ViewGroup.requestSendAccessibilityEvent(View child, AccessibilityEvent event)对于一个View来说，它的Parent View就是ViewGroup，这里会递归调用Parent View的requestSendAccessibilityEvent方法，值得注意的是onRequestSendAccessibilityEvent(View child, AccessibilityEvent event)方法，官方的注释说是“当子View请求发送一个AccessibilityEvent时调用，给父View一个增加事件的机会。” 但我觉得更大的用处是可以通过重写这个方法阻止事件的发送。 我们知道正常情况下，最终我们会调用DecorView的requestSendAccessibilityEvent(View child, AccessibilityEvent event)，而DecorView的Parent是ViewRootImpl，所以说最终会调用ViewRootImpl的requestSendAccessibilityEvent(View child, AccessibilityEvent event)方法。 @Override public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) { ViewParent parent = mParent; if (parent == null) { return false; } // 自定义View可以重写这个方法阻止事件的发送。 final boolean propagate = onRequestSendAccessibilityEvent(child, event); if (!propagate) { return false; } return parent.requestSendAccessibilityEvent(this, event); } 【目标App】ViewRootImpl.requestSendAccessibilityEvent(View child, AccessibilityEvent event)该方法对几个特殊的EventType进行了处理，在此我们先不关注，之后调用AccessibilityManager的sendAccessibilityEvent(AccessibilityEvent event)方法。 public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) { if (mView == null || mStopped || mPausedForTransition) { return false; } final int eventType = event.getEventType(); switch (eventType) { // 对某些eventType进行了特殊处理，在此省略 } mAccessibilityManager.sendAccessibilityEvent(event); return true; } 【目标App】AccessibilityManager.sendAccessibilityEvent(AccessibilityEvent event)这里再次检查了辅助功能当前是否开启，之后就通过Binder进入AccessibilityManagerService【下文简称AMS，额，不要以为是ActivityManagerService】的世界了。 public void sendAccessibilityEvent(AccessibilityEvent event) { final IAccessibilityManager service; final int userId; synchronized (mLock) { service = getServiceLocked(); if (service == null) { return; } if (!mIsEnabled) { Looper myLooper = Looper.myLooper(); if (myLooper == Looper.getMainLooper()) { throw new IllegalStateException( &quot;Accessibility off. Did you forget to check that?&quot;); } else { Log.e(LOG_TAG, &quot;AccessibilityEvent sent with accessibility disabled&quot;); return; } } userId = mUserId; } boolean doRecycle = false; try { event.setEventTime(SystemClock.uptimeMillis()); long identityToken = Binder.clearCallingIdentity(); // 向AccessibilityManagerService发送AccessibilityEvent doRecycle = service.sendAccessibilityEvent(event, userId); Binder.restoreCallingIdentity(identityToken); if (DEBUG) { Log.i(LOG_TAG, event + &quot; sent&quot;); } } catch (RemoteException re) { Log.e(LOG_TAG, &quot;Error during sending &quot; + event + &quot; &quot;, re); } finally { if (doRecycle) { event.recycle(); } } 【AMS】 AccessibilityManagerService.sendAccessibilityEvent(AccessibilityEvent event, int userId)在进行了一些检查和准备工作后，最后调用notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)准备开始分发。 @Override public boolean sendAccessibilityEvent(AccessibilityEvent event, int userId) { synchronized (mLock) { final int resolvedUserId = mSecurityPolicy .resolveCallingUserIdEnforcingPermissionsLocked(userId); if (resolvedUserId != mCurrentUserId) { return true; // yes, recycle the event } if (mSecurityPolicy.canDispatchAccessibilityEventLocked(event)) { mSecurityPolicy.updateActiveAndAccessibilityFocusedWindowLocked(event.getWindowId(), event.getSourceNodeId(), event.getEventType(), event.getAction()); mSecurityPolicy.updateEventSourceLocked(event); // 开始分发AccessibilityEvent notifyAccessibilityServicesDelayedLocked(event, false); notifyAccessibilityServicesDelayedLocked(event, true); } if (mHasInputFilter &amp;&amp; mInputFilter != null) { mMainHandler.obtainMessage(MainHandler.MSG_SEND_ACCESSIBILITY_EVENT_TO_INPUT_FILTER, AccessibilityEvent.obtain(event)).sendToTarget(); } event.recycle(); } return (OWN_PROCESS_ID != Binder.getCallingPid()); } 【AMS】 AccessibilityManagerService.notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)UserState是AccessibilityManagerService一个内部类，在这个类里保存了一个用户当前安装了的、开启了的、已经建立连接的AccessibilityService列表等等信息。在初始化、安装/卸载应用、切换用户、开关辅助功能等等操作时，系统会对UserState的信息进行更新。mBoundServices中保存的就是当前已经启动了的Service列表，Service类也是AccessibilityManagerService的一个内部类，里面储存了从辅助App读取到的配置信息，即我们在辅助App的xml里配置的内容，并且Service类还会负责与各个AccessibilityService建立连接、进行通讯，管理着AccessibilityService的生命周期。此时会调用每个Service的notifyAccessibilityEvent(AccessibilityEvent event)进行事件的分发。 其中canDispatchEventToServiceLocked(Service service, AccessibilityEvent event)方法是用于判断该Service是否可以接收当前的AccessibilityEvent，即根据辅助App配置的需要接收的EventType和packageName等信息进行判断。 private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault) { try { UserState state = getCurrentUserStateLocked(); for (int i = 0, count = state.mBoundServices.size(); i &lt; count; i++) { Service service = state.mBoundServices.get(i); if (service.mIsDefault == isDefault) { // 辅助App接收该packageName和该EventType时才会分发 if (canDispatchEventToServiceLocked(service, event)) { service.notifyAccessibilityEvent(event); } } } } catch (IndexOutOfBoundsException oobe) { // An out of bounds exception can happen if services are going away // as the for loop is running. If that happens, just bail because // there are no more services to notify. } } 【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEvent(AccessibilityEvent event)利用Service里定义的Handler把事件发出去，在handleMessage中进而调用了notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)方法。 public void notifyAccessibilityEvent(AccessibilityEvent event) { synchronized (mLock) { final int eventType = event.getEventType(); // 复制当前的AccessibilityEvent AccessibilityEvent newEvent = AccessibilityEvent.obtain(event); Message message; if ((mNotificationTimeout &gt; 0) &amp;&amp; (eventType != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED)) { // Allow at most one pending event final AccessibilityEvent oldEvent = mPendingEvents.get(eventType); mPendingEvents.put(eventType, newEvent); if (oldEvent != null) { mEventDispatchHandler.removeMessages(eventType); oldEvent.recycle(); } message = mEventDispatchHandler.obtainMessage(eventType); } else { // Send all messages, bypassing mPendingEvents message = mEventDispatchHandler.obtainMessage(eventType, newEvent); } mEventDispatchHandler.sendMessageDelayed(message, mNotificationTimeout); } } public Handler mEventDispatchHandler = new Handler(mMainHandler.getLooper()) { @Override public void handleMessage(Message message) { final int eventType = message.what; AccessibilityEvent event = (AccessibilityEvent) message.obj; notifyAccessibilityEventInternal(eventType, event); } }; 【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)该方法中的IAccessibilityServiceClient是AccessibilityService中的内部类IAccessibilityServiceClientWrapper，通过Binder调用了其onAccessibilityEvent(AccessibilityEvent event)方法。之后我们便转入了辅助App也就是接收辅助事件的App中。 private void notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event) { IAccessibilityServiceClient listener; synchronized (mLock) { listener = mServiceInterface; // If the service died/was disabled while the message for dispatching // the accessibility event was propagating the listener may be null. if (listener == null) { return; } if (event == null) { event = mPendingEvents.get(eventType); if (event == null) { return; } mPendingEvents.remove(eventType); } if (mSecurityPolicy.canRetrieveWindowContentLocked(this)) { event.setConnectionId(mId); } else { event.setSource(null); } event.setSealed(true); } try { // 分发给辅助App listener.onAccessibilityEvent(event); if (DEBUG) { Slog.i(LOG_TAG, &quot;Event &quot; + event + &quot; sent to &quot; + listener); } } catch (RemoteException re) { Slog.e(LOG_TAG, &quot;Error during sending &quot; + event + &quot; to &quot; + listener, re); } finally { event.recycle(); } } 【辅助App】 AccessibilityService.IAccessibilityServiceClientWrapper.onAccessibilityEvent(AccessibilityEvent event)此时通过mCaller发送了message code为DO_ON_ACCESSIBILITY_EVENT的Message，mCaller是IAccessibilityServiceClientWrapper中持有的一个HandlerCaller，在IAccessibilityServiceClientWrapper的构造方法中通过mCaller = new HandlerCaller(context, looper, this, true /asyncHandler/)创建，其中第三个参数即HandlerCaller的Callback，因此最终会回调IAccessibilityServiceClientWrapper的executeMessage方法。 在此我们只看message code为DO_ON_ACCESSIBILITY_EVENT的实现，可以看到最后调用的是mCallback.onAccessibilityEvent(event)，这个mCallback是什么呢？在AccessibilityService里定义了一个接口Callbacks，IAccessibilityServiceClientWrapper中持有的这个Callbacks是由其构造方法传入的参数。而IAccessibilityServiceClientWrapper是在AccessibilityService的onBind(Intent intent)方法中生成了，其中Callbacks的onAccessibilityEvent(AccessibilityEvent event)方法实现非常简单，直接调用了AccessibilityService.this.onAccessibilityEvent(event)，这个也就是我们在辅助App中重写的onAccessibilityEvent(AccessibilityEvent event)方法了。 public void onAccessibilityEvent(AccessibilityEvent event) { Message message = mCaller.obtainMessageO(DO_ON_ACCESSIBILITY_EVENT, event); mCaller.sendMessage(message); } public void executeMessage(Message message) { switch (message.what) { case DO_ON_ACCESSIBILITY_EVENT: { AccessibilityEvent event = (AccessibilityEvent) message.obj; if (event != null) { // 如果是设计UI方面的eventType会对一些缓存进行更新 AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event); mCallback.onAccessibilityEvent(event); // Make sure the event is recycled. try { event.recycle(); } catch (IllegalStateException ise) { /* ignore - best effort */ } } } return; ...// 其他实现省略 } } @Override public void onAccessibilityEvent(AccessibilityEvent event) { AccessibilityService.this.onAccessibilityEvent(event); } 总结到此，AccessibilityEvent便由目标App经由AccessibilityManagerService发送到了辅助App上，如果用图展示的话大致如下（图中省去了部分Handler的流程）： 点击查看大图 Accessibility 补遗目标App与AccessibilityManagerService的通讯其实目标App与AccessibilityManagerService之间除了在发送AccessibilityEvent时进行了通讯外，在第一次连接获取辅助服务开关状态以及开关状态发生变化时都会进行通讯。判断辅助服务是否开启的逻辑如下： public boolean isEnabled() { synchronized (mLock) { IAccessibilityManager service = getServiceLocked(); if (service == null) { return false; } return mIsEnabled; } } private IAccessibilityManager getServiceLocked() { if (mService == null) { tryConnectToServiceLocked(null); } return mService; } private void tryConnectToServiceLocked(IAccessibilityManager service) { if (service == null) { IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE); if (iBinder == null) { return; } service = IAccessibilityManager.Stub.asInterface(iBinder); } try { // 向AccessibilityManagerService添加client时会返回当前开关状态 final int stateFlags = service.addClient(mClient, mUserId); setStateLocked(stateFlags); mService = service; } catch (RemoteException re) { Log.e(LOG_TAG, &quot;AccessibilityManagerService is dead&quot;, re); } } AccessibilityManager中用mIsEnabled变量标识当前辅助功能是否开启，如果当前已经和AccessibilityManagerService建立了联系则直接返回该标识，如果没有会尝试和AccessibilityManagerService联系，调用AccessibilityManagerService.addClient(mClient, mUserId)方法就能得到当前辅助功能的开关状态，之后通过setStateLocked(stateFlags)给mIsEnabled变量赋值。 private void setStateLocked(int stateFlags) { final boolean enabled = (stateFlags &amp; STATE_FLAG_ACCESSIBILITY_ENABLED) != 0; final boolean touchExplorationEnabled = (stateFlags &amp; STATE_FLAG_TOUCH_EXPLORATION_ENABLED) != 0; final boolean highTextContrastEnabled = (stateFlags &amp; STATE_FLAG_HIGH_TEXT_CONTRAST_ENABLED) != 0; final boolean wasEnabled = mIsEnabled; final boolean wasTouchExplorationEnabled = mIsTouchExplorationEnabled; final boolean wasHighTextContrastEnabled = mIsHighTextContrastEnabled; // Ensure listeners get current state from isZzzEnabled() calls. mIsEnabled = enabled; mIsTouchExplorationEnabled = touchExplorationEnabled; mIsHighTextContrastEnabled = highTextContrastEnabled; if (wasEnabled != enabled) { mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_ACCESSIBILITY_STATE_CHANGED); } if (wasTouchExplorationEnabled != touchExplorationEnabled) { mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_EXPLORATION_STATE_CHANGED); } if (wasHighTextContrastEnabled != highTextContrastEnabled) { mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_HIGH_TEXT_CONTRAST_STATE_CHANGED); } } 除此之外还可以看到我们可以向AccessibilityManager注册一些AccessibilityStateChangeListener，当开关状态发生变化时我们能拿到相应的回调。 在调用AccessibilityManagerService.addClient(mClient, mUserId)时，目标App就向AccessibilityManagerService注册了自己，mClient代码如下： private final IAccessibilityManagerClient.Stub mClient = new IAccessibilityManagerClient.Stub() { public void setState(int state) { mHandler.obtainMessage(MyHandler.MSG_SET_STATE, state, 0).sendToTarget(); } }; 当辅助功能开关变化时，AccessibilityManagerService会调用每个client的setState(int state)方法，通过Handler又调用了setStateLocked(state)方法修改了开关状态。 第7步AccessibilityManagerService进行了哪些检查和准备系统不允许后台用户发送AccessibilityEvent，所以首先会检查处理后的UserId是否和当前UserId一样。实际使用中，多用户的情况并不多，所以我们基本无需考虑UserId的问题。 public int resolveCallingUserIdEnforcingPermissionsLocked(int userId) { final int callingUid = Binder.getCallingUid(); if (callingUid == 0 || callingUid == Process.SYSTEM_UID || callingUid == Process.SHELL_UID) { if (userId == UserHandle.USER_CURRENT || userId == UserHandle.USER_CURRENT_OR_SELF) { return mCurrentUserId; } return resolveProfileParentLocked(userId); } final int callingUserId = UserHandle.getUserId(callingUid); if (callingUserId == userId) { return resolveProfileParentLocked(userId); } final int callingUserParentId = resolveProfileParentLocked(callingUserId); if (callingUserParentId == mCurrentUserId &amp;&amp; (userId == UserHandle.USER_CURRENT || userId == UserHandle.USER_CURRENT_OR_SELF)) { return mCurrentUserId; } if (!hasPermission(Manifest.permission.INTERACT_ACROSS_USERS) &amp;&amp; !hasPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL)) { throw new SecurityException(&quot;Call from user &quot; + callingUserId + &quot; as user &quot; + userId + &quot; without permission INTERACT_ACROSS_USERS or &quot; + &quot;INTERACT_ACROSS_USERS_FULL not allowed.&quot;); } if (userId == UserHandle.USER_CURRENT || userId == UserHandle.USER_CURRENT_OR_SELF) { return mCurrentUserId; } throw new IllegalArgumentException(&quot;Calling user can be changed to only &quot; + &quot;UserHandle.USER_CURRENT or UserHandle.USER_CURRENT_OR_SELF.&quot;); } private int resolveProfileParentLocked(int userId) { if (userId != mCurrentUserId) { final long identity = Binder.clearCallingIdentity(); try { UserInfo parent = mUserManager.getProfileParent(userId); if (parent != null) { return parent.getUserHandle().getIdentifier(); } } finally { Binder.restoreCallingIdentity(identity); } } return userId; } 之后会检查这个AccessibilityEvent能不能分发，见下面的代码，一部分EventType是必定可以分发的，其他的EventType会再检查Window的情况。 private boolean canDispatchAccessibilityEventLocked(AccessibilityEvent event) { final int eventType = event.getEventType(); switch (eventType) { case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED: case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED: case AccessibilityEvent.TYPE_ANNOUNCEMENT: case AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_START: case AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_END: case AccessibilityEvent.TYPE_GESTURE_DETECTION_START: case AccessibilityEvent.TYPE_GESTURE_DETECTION_END: case AccessibilityEvent.TYPE_TOUCH_INTERACTION_START: case AccessibilityEvent.TYPE_TOUCH_INTERACTION_END: case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER: case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT: case AccessibilityEvent.TYPE_ASSIST_READING_CONTEXT: case AccessibilityEvent.TYPE_WINDOWS_CHANGED: { return true; } default: { return isRetrievalAllowingWindow(event.getWindowId()); } } } private boolean isRetrievalAllowingWindow(int windowId) { // The system gets to interact with any window it wants. if (Binder.getCallingUid() == Process.SYSTEM_UID) { return true; } if (windowId == mActiveWindowId) { return true; } return findWindowById(windowId) != null; } 这2项检查通过之后，就准备分发事件了，updateActiveAndAccessibilityFocusedWindowLocked方法主要更新了一些跟Window相关的东西，而updateEventSourceLocked方法则是会把不在RETRIEVAL_ALLOWING_EVENT_TYPES之中的AccessibilityEvent的source置为null。 private static final int RETRIEVAL_ALLOWING_EVENT_TYPES = AccessibilityEvent.TYPE_VIEW_CLICKED | AccessibilityEvent.TYPE_VIEW_FOCUSED | AccessibilityEvent.TYPE_VIEW_HOVER_ENTER | AccessibilityEvent.TYPE_VIEW_HOVER_EXIT | AccessibilityEvent.TYPE_VIEW_LONG_CLICKED | AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED | AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | AccessibilityEvent.TYPE_VIEW_SELECTED | AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED | AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED | AccessibilityEvent.TYPE_VIEW_SCROLLED | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED | AccessibilityEvent.TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY;","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.darkness463.top/tags/Android/"},{"name":"Accessibility","slug":"Accessibility","permalink":"https://blog.darkness463.top/tags/Accessibility/"}]},{"title":"【笔记】Java虚拟机(一)-GC","date":"2017-03-30T07:00:00.000Z","path":"2017/03/30/Java-VM-GC/","text":"很久以前看《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书时，做了一些笔记，分享一下，还有几篇会陆续发上来。文中的东西基本都来自书中。 判断对象是否存活 引用计数算法（Reference Counting） 给对象中添加一个引用计数器，当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是还不可能再被使用的。实现简单，判定效率高，但很难解决对象之间相互循环引用的问题。 可达性分析算法（Reachability Analysis） 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链项链时，则证明此对象是不可用的。 Java中可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（Native方法）引用的对象。 可达性分析 Java中引用关系 强引用（Strong Reference） 类似Object obj = new Object()的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用（Soft Reference） 用来描述一些还有用但非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。 弱引用（Weak Reference） 用来描述非必需对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 虚引用（Phantom Reference） 也称幽灵引用或幻影引用，最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 finalize方法 当对象进行可达性分析后发现没有与GC Roots相连接的引用链，将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，则视为“没有必要执行”。【因此finalize()方法只会被执行一次】 执行finalize()方法时，会将该对象放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行（触发finalize()方法但不承诺会等待它运行结束，防止finalize()方法执行缓慢导致阻塞）。稍后GC会对F-Queue中的对象进行二次标记，如果对象在finalize()方法中使自己与任一对象建立关联，将被移除出“即将回收”的集合，否则将真正回收。但注意finalize()方法只会执行一次。 不推荐使用。 垃圾收集算法 标记-清除（Mark-Sweep）算法 先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 不足： 效率问题，标记和清除两个过程的效率都不高； 空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制（Copying）算法 将内存划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。 为减少内存的浪费，实际按8：1：1的比例分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，然后清理掉Eden和刚才用过的Survivor空间。当另一块Survivor空间不足存放Eden和Survivor中存活的对象时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。 标记-整理（Mark-Compact）算法 标记过程仍然与“标记-清除”算法一样，但不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 老年代一般采用该种算法。 分代收集（Generational Collection）算法 当前商用虚拟机的垃圾收集都采用分代收集算法。一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。 垃圾收集器 Serial收集器 单线程的收集器，进行垃圾收集时，必须暂停其他所以的工作线程，直到它收集结束（Stop The World）。复制算法。 ParNew收集器 Serial收集器的多线程版本，除使用多条线程进行垃圾收集外其余与Serial收集器一样。复制算法。 Parallel Scavenge收集器 复制算法，并行的多线程收集器。“吞吐量优先”，达到一个可控制的吞吐量（Throughput），吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。 Serial Old收集器 单线程，“标记-整理”算法。 Parallel Old收集器 多线程，“标记-整理”算法。 CMS收集器（Concurrent Mark Sweep） 以获取最短回收停顿时间为目标的收集器。“标记-清除”算法。整个过程分为4个步骤，耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。 初始标记（CMS initial mark） 需stop the world，仅仅标记一下GC Roots能直接关联到的对象，速度很快。 并发标记（CMS concurrent mark） 进行GC Roots Tracing。 重新标记（CMS remark） 需stop the world，修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。 并发清除（CMS concurrent sweep） G1收集器（Garbage-First） 特点：并行、并发、分代收集、整体“标记-整理”局部（两个Region之间）“复制”算法、可预测的停顿。将整个Java堆划分为多个大小相等的独立区域（Region），跟着各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。步骤：初始标记（Initial Marking）、并发标记（Concurrent Marking）、最终标记（Final Marking）、筛选回收（Live Data Counting and Evacuation） 内存分配与回收策略 对象优先在Eden分配 大多数情况下，对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 大对象直接进入老年代 大对象即需要大量连续内存空间的Java对象，如很长的字符串和数组。 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），将会被晋升到老年代中。 动态对象年龄判断 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到设置要求的年龄。 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，如果小于，或者HandlePromotionFailure设置不允许冒险，则改为进行一次Full GC。","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.darkness463.top/tags/Java/"},{"name":"GC","slug":"GC","permalink":"https://blog.darkness463.top/tags/GC/"}]}]