<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>变猴旅程</title>
  
  <subtitle>从人变猴的历程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.darkness463.top/"/>
  <updated>2018-04-10T13:34:38.370Z</updated>
  <id>https://blog.darkness463.top/</id>
  
  <author>
    <name>Darkness463</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【All in One】Once</title>
    <link href="https://blog.darkness463.top/2018/04/10/All-in-One-Once/"/>
    <id>https://blog.darkness463.top/2018/04/10/All-in-One-Once/</id>
    <published>2018-04-10T13:33:13.000Z</published>
    <updated>2018-04-10T13:34:38.370Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jonfinerty/Once" target="_blank" rel="noopener">Once</a>是一个开源的用于管理一些只需要进行一次（或几次）的操作的库。比如说只显示一次引导页，每个版本只显示一次更新说明等等。</p><a id="more"></a><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.jonathanfinerty.once:once:1.2.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Once.initialise(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>检测某项操作是否已进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String showWhatsNew = <span class="string">"showWhatsNewTag"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否需要进行操作</span></span><br><span class="line"><span class="keyword">if</span> (!Once.beenDone(Once.THIS_APP_VERSION, showWhatsNew)) &#123;</span><br><span class="line">    startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, WhatsNewActivity.class));</span><br><span class="line">    <span class="comment">// 完成后进行标记</span></span><br><span class="line">    Once.markDone(showWhatsNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once支持3种尺度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">THIS_APP_INSTALL: 安装到卸载前，例如引导页只出现一次，升级也不重复出现。</span><br><span class="line">THIS_APP_VERSION: 当前版本，例如更新说明，一个版本出现一次。</span><br><span class="line">THIS_APP_SESSION: 本次使用。</span><br></pre></td></tr></table></figure><p>此外，也支持如果时间，在设定的时间内进行一次操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Once.beenDone(TimeUnit.HOURS, <span class="number">1</span>, phonedHome) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Once还支持将某件事标记为”to do”，之后检查是否需要做某项操作。Once给我们举了个例子，有时你想在用户看到基础功能后，在MainActivity中显示一些高级功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// in the basic functionality activity</span></span><br><span class="line">Once.toDo(Once.THIS_APP_INSTALL, <span class="string">"show feature onboarding"</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// back in the home activity</span></span><br><span class="line"><span class="keyword">if</span> (Once.needToDo(showAppTour)) &#123;</span><br><span class="line">    <span class="comment">// do some operations</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after task has been done, mark it as done as normal</span></span><br><span class="line">    Once.markDone(showAppTour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了进行一次，Once也支持第N次后进行某些操作。例如，在用户使用3次App后弹出让用户评分的dialog。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once again in the basic functionality activity</span></span><br><span class="line">Once.markDone(<span class="string">"action"</span>);</span><br><span class="line"><span class="keyword">if</span> (Once.beenDone(<span class="string">"action"</span>, Amount.exactly(<span class="number">3</span>))) &#123;</span><br><span class="line">    showRateTheAppDialog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持下面这三种</span></span><br><span class="line">Amount.exactly(<span class="keyword">int</span> x)   <span class="comment">// 第x次时</span></span><br><span class="line">Amount.lessThan(<span class="keyword">int</span> x)  <span class="comment">// 小于x次时</span></span><br><span class="line">Amount.moreThan(<span class="keyword">int</span> x)  <span class="comment">// 大于x次时</span></span><br></pre></td></tr></table></figure><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>Once的功能很简单，如果不使用Once而是自己实现的话，我们必然会用SharedPreferences去记录是否进行过某些操作，Once的实现也是类似的。</p><h2 id="PersistedMap和PersistedSet"><a href="#PersistedMap和PersistedSet" class="headerlink" title="PersistedMap和PersistedSet"></a>PersistedMap和PersistedSet</h2><p>这两个类是Once中保存和处理SharedPreferences。PersistedMap对应名为PersistedMapTagLastSeenMap的sp，用于保存那些被markDone的tag的时间戳，sp中保存的key为tag，value为时间戳拼成的字符串，以逗号分隔各时间戳，在PersistedMap中保存在<code>Map&lt;String, List&lt;Long&gt;&gt; map</code>对象中，map的key为tag，List即为由时间戳字符串还原成的list。PersistedSet对应名为PersistedSetToDoSet的sp，用于保存被标记为todo的tag，Android3.0以上的版本直接已Set的形式保存在sp中，3.0以下以字符串形式保存，用逗号分隔。</p><p>PersistedMap和PersistedSet的实现类似，初始化时通过AsyncTask异步去加载各自的SharedPreferences，提供put、remove等方法，调用这些方法会更新内存中的Map/Set，并更新sp。</p><h2 id="AsyncSharedPreferenceLoader"><a href="#AsyncSharedPreferenceLoader" class="headerlink" title="AsyncSharedPreferenceLoader"></a>AsyncSharedPreferenceLoader</h2><p>供PersistedMap和PersistedSet加载SharedPreferences使用。内部实现了一个AsyncTask用于异步加载SharedPreferences，并提供get()方法用于获取加载后的SharedPreferences。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncTask&lt;String, Void, SharedPreferences&gt; asyncTask = <span class="keyword">new</span> AsyncTask&lt;String, Void, SharedPreferences&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SharedPreferences <span class="title">doInBackground</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getSharedPreferences(names[<span class="number">0</span>], Context.MODE_PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SharedPreferences <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> asyncTask.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException ignored) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>Once的主类，提供了Once能实现的所有功能。这里只介绍一些主要方法的实现。</p><h3 id="initialise"><a href="#initialise" class="headerlink" title="initialise"></a>initialise</h3><p>初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialise</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化PersistedMap和PersistedSet</span></span><br><span class="line">    tagLastSeenMap = <span class="keyword">new</span> PersistedMap(context, <span class="string">"TagLastSeenMap"</span>);</span><br><span class="line">    toDoSet = <span class="keyword">new</span> PersistedSet(context, <span class="string">"ToDoSet"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sessionList用于保存处理THIS_APP_SESSION级别的tag。</span></span><br><span class="line">    <span class="keyword">if</span> (sessionList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sessionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取lastAppUpdatedTime，用于处理THIS_APP_VERSION级别。</span></span><br><span class="line">    PackageManager packageManager = context.getPackageManager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageInfo packageInfo = packageManager.getPackageInfo(context.getPackageName(), <span class="number">0</span>);</span><br><span class="line">        lastAppUpdatedTime = packageInfo.lastUpdateTime;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException ignored) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="markDone"><a href="#markDone" class="headerlink" title="markDone"></a>markDone</h3><p>用于记录某个tag对应的操作的完成。会将当前时间戳增加进PersistedMap中，向sessionList中添加该tag，并从PersistedSet中将该tag移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markDone</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">    tagLastSeenMap.put(tag, <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    sessionList.add(tag);</span><br><span class="line">    toDoSet.remove(tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beenDone"><a href="#beenDone" class="headerlink" title="beenDone"></a>beenDone</h3><p>用于判断某个tag是否已完成。有一系列重载的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THIS_APP_INSTALL级别，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(String tag);</span><br><span class="line"><span class="comment">// THIS_APP_INSTALL级别，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(String tag, CountChecker numberOfTimes);</span><br><span class="line"><span class="comment">// 自定义scope，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(<span class="meta">@Scope</span> <span class="keyword">int</span> scope, String tag);</span><br><span class="line"><span class="comment">// 自定义scope，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(<span class="meta">@Scope</span> <span class="keyword">int</span> scope, String tag, CountChecker numberOfTimes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// amount * timeUnit之前至今，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(TimeUnit timeUnit, <span class="keyword">long</span> amount, String tag);</span><br><span class="line"><span class="comment">// amount * timeUnit之前至今，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(TimeUnit timeUnit, <span class="keyword">long</span> amount, String tag, CountChecker numberOfTimes);</span><br><span class="line"><span class="comment">// timeSpanInMillis之前至今，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(<span class="keyword">long</span> timeSpanInMillis, String tag);</span><br><span class="line"><span class="comment">// timeSpanInMillis之前至今，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(<span class="keyword">long</span> timeSpanInMillis, String tag, CountChecker numberOfTimes);</span><br></pre></td></tr></table></figure><p>前4个方法以scope为维度，最终都会调用到<code>beenDone(@Scope int scope, String tag, CountChecker numberOfTimes)</code>，后4个方法以时间为维度，最终都会调用<code>beenDone(long timeSpanInMillis, String tag, CountChecker numberOfTimes)</code>，我们来看一下这2个方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">beenDone</span><span class="params">(@Scope <span class="keyword">int</span> scope, String tag, CountChecker numberOfTimes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该tag所有的记录。</span></span><br><span class="line">    List&lt;Long&gt; tagSeenDates = tagLastSeenMap.get(tag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagSeenDates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">    <span class="keyword">if</span> (scope == THIS_APP_INSTALL) &#123;</span><br><span class="line">        <span class="comment">// THIS_APP_INSTALL级别，直接和记录的size比较。</span></span><br><span class="line">        <span class="keyword">return</span> numberOfTimes.check(tagSeenDates.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == THIS_APP_SESSION) &#123;</span><br><span class="line">        <span class="comment">// THIS_APP_SESSION级别，和sessionList中该tag的个数比较。</span></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String tagFromList : sessionList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagFromList.equals(tag)) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numberOfTimes.check(counter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// THIS_APP_VERSION级别，记录中大于lastAppUpdatedTime的才计算进去。</span></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long seenDate : tagSeenDates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seenDate &gt; lastAppUpdatedTime) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numberOfTimes.check(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">beenDone</span><span class="params">(<span class="keyword">long</span> timeSpanInMillis, String tag, CountChecker numberOfTimes)</span> </span>&#123;</span><br><span class="line">    List&lt;Long&gt; tagSeenDates = tagLastSeenMap.get(tag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagSeenDates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Long seenDate : tagSeenDates) &#123;</span><br><span class="line">        <span class="comment">// 计算出最小的有效时间</span></span><br><span class="line">        <span class="keyword">long</span> sinceSinceCheckTime = <span class="keyword">new</span> Date().getTime() - timeSpanInMillis;</span><br><span class="line">        <span class="comment">// 比较记录的时间和有效时间，比有效时间大的才计入。</span></span><br><span class="line">        <span class="keyword">if</span> (seenDate &gt; sinceSinceCheckTime) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numberOfTimes.check(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toDo-needToDo"><a href="#toDo-needToDo" class="headerlink" title="toDo/needToDo"></a>toDo/needToDo</h3><p>toDo用于标记某个tag “need to do”。有<code>toDo(@Scope int scope, String tag)</code>和<code>toDo(String tag)</code>2个方法。需要注意的是，使用<code>toDo(@Scope int scope, String tag)</code>时，如果该tag之前被markDone过，则仅当传入的scope为THIS_APP_VERSION且该tag上次被markDone的时间在lastAppUpdatedTime之前才会将该tag添加到PersistedSet中。而<code>toDo(String tag)</code>则无论该tag之前有没有被markDone，都会添加到PersistedSet中。<br>needToDo即用于检查PersistedSet中是否存在对应的tag。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Once可以帮我们方便地管理一些操作在什么时候进行。</li><li>利用SharedPreferences保存记录。</li><li>支持<code>THIS_APP_INSTALL</code>、<code>THIS_APP_VERSION</code>、<code>THIS_APP_SESSION</code>三种级别。利用每次markDone的时间戳实现对三种级别的支持。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/jonfinerty/Once&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Once&lt;/a&gt;是一个开源的用于管理一些只需要进行一次（或几次）的操作的库。比如说只显示一次引导页，每个版本只显示一次更新说明等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
      <category term="All in One" scheme="https://blog.darkness463.top/tags/All-in-One/"/>
    
      <category term="Once" scheme="https://blog.darkness463.top/tags/Once/"/>
    
  </entry>
  
  <entry>
    <title>Android-ConditionVariable</title>
    <link href="https://blog.darkness463.top/2018/03/28/Android-ConditionVariable/"/>
    <id>https://blog.darkness463.top/2018/03/28/Android-ConditionVariable/</id>
    <published>2018-03-28T02:08:39.000Z</published>
    <updated>2018-03-28T02:09:48.674Z</updated>
    
    <content type="html"><![CDATA[<p>ConditionVariable是Android提供的用于wait和notify的类，与java的wait()和notify()不同的地方在于ConditionVarible可以根据状态决定是否wait。</p><a id="more"></a><h2 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h2><p>ConditionVariable有四个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 释放所以block的线程，且将状态设置为open，如果之后不调用close()，则调用block()不会阻塞。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将状态设置为close。之后调用block()将会阻塞。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果状态不为open，则阻塞当前线程直到调用open()，否则直接返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">block</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果状态不为open，则阻塞当前线程直到调用open()或达到timeout时间，否则直接返回。</span></span><br><span class="line"><span class="comment">* 如果是因为open而返回，则返回true，如果是因为超市而返回，则返回false。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">block</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>ConditionVariable的实现非常简单，根据<code>mCondition</code>变量的值决定当前是open还是close状态，<code>mCondition</code>等于true时为open，false时为close。调用block()时，仅在<code>mCondition</code>等于false时才会调用wait()。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ConditionVariable简化了wait()和notify()的编写，如果需要根据情况决定是否wait，可以考虑使用ConditionVariable。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConditionVariable是Android提供的用于wait和notify的类，与java的wait()和notify()不同的地方在于ConditionVarible可以根据状态决定是否wait。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>废话几句</title>
    <link href="https://blog.darkness463.top/2018/03/27/say-something/"/>
    <id>https://blog.darkness463.top/2018/03/27/say-something/</id>
    <published>2018-03-27T15:21:17.000Z</published>
    <updated>2018-03-27T15:27:42.705Z</updated>
    
    <content type="html"><![CDATA[<p><em>全是废话</em></p><a id="more"></a><p>当初在Github上搭了这个站之后就几乎没发过什么东西，后来买了一个域名也没有鸟过了。</p><p>这两天看到了由<a href="https://github.com/yscoder" target="_blank" rel="noopener">yscoder</a>开源的hexo主题<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">hexo-theme-indigo</a>，挺好看的，于是把之前的推倒重来了。</p><p>之前的几篇东西受限于当时知识的有限，有一些不太对的地方，但是懒得改了，所以也就不放上来了，只把几篇总结笔记类的改了格式传上来了。</p><p>之后多写点东西吧(大概吧)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;全是废话&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【总结】Android辅助功能(一)-AccessibilityEvent的分发</title>
    <link href="https://blog.darkness463.top/2017/04/17/accessibility-event/"/>
    <id>https://blog.darkness463.top/2017/04/17/accessibility-event/</id>
    <published>2017-04-17T05:41:10.000Z</published>
    <updated>2018-03-27T15:28:41.853Z</updated>
    
    <content type="html"><![CDATA[<p>目前关于辅助功能的使用的文章很多，但鲜有分析其具体实现的，本文基于Andoird 7.1.0_r7源码分析一下辅助事件是怎么分发的，只涉及事件的分发和辅助App的接收，之后有机会再讲一讲获取AccessibilityNodeInfo、进行操作等等的源码流程。<br><a id="more"></a><br>文中“目标App”指的是发出辅助事件的App，“辅助App”指的是拥有辅助功能的App。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="【目标App】-View-sendAccessibilityEvent-int-eventType"><a href="#【目标App】-View-sendAccessibilityEvent-int-eventType" class="headerlink" title="【目标App】 View.sendAccessibilityEvent(int eventType)"></a>【目标App】 View.sendAccessibilityEvent(int eventType)</h2><p>我们看View的源码可以看到在很多地方调用了sendAccessibilityEvent(int eventType)的方法，例如：</p><pre><code>在View获取到焦点时，调用了sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED)；当View被点击时，调用了sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED)</code></pre><p>使用过辅助功能的同学对这些Event应该很熟悉，这些就是我们在写辅助App时定义的想要接收的辅助事件的类型，Android为我们定义了一系列辅助事件，这里举几个比较常用的事件：</p><pre><code>TYPE_VIEW_CLICKED    // 当View被点击时发送此事件。TYPE_VIEW_LONG_CLICKED    // 当View被长按时发送此事件。TYPE_VIEW_FOCUSED    // 当View获取到焦点时发送此事件。TYPE_WINDOW_STATE_CHANGED    // 当Window发生变化时发送此事件。TYPE_VIEW_SCROLLED    // 当View滑动时发送此事件。</code></pre><p>所以说，sendAccessibilityEvent(int eventType)就是我们的起点，我们来看一看这个方法。View实现了AccessibilityEventSource接口，这个方法就来自于AccessibilityEventSource接口。</p><pre><code>public void sendAccessibilityEvent(int eventType) {    if (mAccessibilityDelegate != null) {        // AccessibilityDelegate是用来增强辅助功能的，一般情况下不用考虑。        mAccessibilityDelegate.sendAccessibilityEvent(this, eventType);    } else {        sendAccessibilityEventInternal(eventType);    }}</code></pre><h2 id="【目标App】-View-sendAccessibilityEventInternal-int-eventType-gt-View-sendAccessibilityEventUnchecked-AccessibilityEvent-event"><a href="#【目标App】-View-sendAccessibilityEventInternal-int-eventType-gt-View-sendAccessibilityEventUnchecked-AccessibilityEvent-event" class="headerlink" title="【目标App】 View.sendAccessibilityEventInternal(int eventType) -&gt; View.sendAccessibilityEventUnchecked(AccessibilityEvent event)"></a>【目标App】 View.sendAccessibilityEventInternal(int eventType) -&gt; View.sendAccessibilityEventUnchecked(AccessibilityEvent event)</h2><p>这2个方法都比较短，就放在一起说了。sendAccessibilityEventInternal(int eventType)会检查当前辅助服务是否开启，至少有一个辅助App被开启了才会返回true。如果当前开启了，会把eventType转成AccessibilityEvent，这就是我们在AccessibilityService中收到的AccessibilityEvent，之后调用了sendAccessibilityEventUnchecked(AccessibilityEvent event)，进而调用了sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)。</p><pre><code>public void sendAccessibilityEventInternal(int eventType) {    if (AccessibilityManager.getInstance(mContext).isEnabled()) {        sendAccessibilityEventUnchecked(AccessibilityEvent.obtain(eventType));    }}public void sendAccessibilityEventUnchecked(AccessibilityEvent event) {    if (mAccessibilityDelegate != null) {        // AccessibilityDelegate是用来增强辅助功能的，一般情况下不用考虑。        mAccessibilityDelegate.sendAccessibilityEventUnchecked(this, event);    } else {        sendAccessibilityEventUncheckedInternal(event);    }}</code></pre><h2 id="【目标App】-View-sendAccessibilityEventUncheckedInternal-AccessibilityEvent-event"><a href="#【目标App】-View-sendAccessibilityEventUncheckedInternal-AccessibilityEvent-event" class="headerlink" title="【目标App】 View.sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)"></a>【目标App】 View.sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)</h2><p>此时会先判断当前View及所有的Parent是否可见，如果不可见则不会分发当前的AccessibilityEvent。onInitializeAccessibilityEvent(event)做了一些初始化工作，例如给AccessibilityEvent设置source、className、packageName等等信息。</p><p>系统定义了一个叫POPULATING_ACCESSIBILITY_EVENT_TYPES的常量，包括了AccessibilityEvent.TYPE_VIEW_CLICKED等等一系列Event，当发送的EventType是这些中的一个时，目标App可以通过重写dispatchPopulateAccessibilityEvent(AccessibilityEvent event)或onPopulateAccessibilityEvent(AccessibilityEvent event)方法对将要发送的AccessibilityEvent进行修改。</p><p>之后会调用getParent().requestSendAccessibilityEvent(this, event)发给Parent View去处理。</p><pre><code>public void sendAccessibilityEventUncheckedInternal(AccessibilityEvent event) {    // 判断View是否可见    if (!isShown()) {        return;    }    // 设置AccessibilityEvent的一些信息    onInitializeAccessibilityEvent(event);    if ((event.getEventType() &amp; POPULATING_ACCESSIBILITY_EVENT_TYPES) != 0) {        // 目标App可通过此方法修改AccessibilityEvent        dispatchPopulateAccessibilityEvent(event);    }    // In the beginning we called #isShown(), so we know that getParent() is not null.    getParent().requestSendAccessibilityEvent(this, event);}private static final int POPULATING_ACCESSIBILITY_EVENT_TYPES =        AccessibilityEvent.TYPE_VIEW_CLICKED        | AccessibilityEvent.TYPE_VIEW_LONG_CLICKED        | AccessibilityEvent.TYPE_VIEW_SELECTED        | AccessibilityEvent.TYPE_VIEW_FOCUSED        | AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED        | AccessibilityEvent.TYPE_VIEW_HOVER_ENTER        | AccessibilityEvent.TYPE_VIEW_HOVER_EXIT        | AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED        | AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED        | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED        | AccessibilityEvent.TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY;</code></pre><h2 id="【目标App】ViewGroup-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event"><a href="#【目标App】ViewGroup-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event" class="headerlink" title="【目标App】ViewGroup.requestSendAccessibilityEvent(View child, AccessibilityEvent event)"></a>【目标App】ViewGroup.requestSendAccessibilityEvent(View child, AccessibilityEvent event)</h2><p>对于一个View来说，它的Parent View就是ViewGroup，这里会递归调用Parent View的requestSendAccessibilityEvent方法，值得注意的是onRequestSendAccessibilityEvent(View child, AccessibilityEvent event)方法，官方的注释说是“当子View请求发送一个AccessibilityEvent时调用，给父View一个增加事件的机会。” 但我觉得更大的用处是可以通过重写这个方法阻止事件的发送。</p><p>我们知道正常情况下，最终我们会调用DecorView的requestSendAccessibilityEvent(View child, AccessibilityEvent event)，而DecorView的Parent是ViewRootImpl，所以说最终会调用ViewRootImpl的requestSendAccessibilityEvent(View child, AccessibilityEvent event)方法。</p><pre><code>@Overridepublic boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {    ViewParent parent = mParent;    if (parent == null) {        return false;    }    // 自定义View可以重写这个方法阻止事件的发送。    final boolean propagate = onRequestSendAccessibilityEvent(child, event);    if (!propagate) {        return false;    }    return parent.requestSendAccessibilityEvent(this, event);}</code></pre><h2 id="【目标App】ViewRootImpl-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event"><a href="#【目标App】ViewRootImpl-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event" class="headerlink" title="【目标App】ViewRootImpl.requestSendAccessibilityEvent(View child, AccessibilityEvent event)"></a>【目标App】ViewRootImpl.requestSendAccessibilityEvent(View child, AccessibilityEvent event)</h2><p>该方法对几个特殊的EventType进行了处理，在此我们先不关注，之后调用AccessibilityManager的sendAccessibilityEvent(AccessibilityEvent event)方法。</p><pre><code>public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {    if (mView == null || mStopped || mPausedForTransition) {        return false;    }    final int eventType = event.getEventType();    switch (eventType) {        // 对某些eventType进行了特殊处理，在此省略    }    mAccessibilityManager.sendAccessibilityEvent(event);    return true;}</code></pre><h2 id="【目标App】AccessibilityManager-sendAccessibilityEvent-AccessibilityEvent-event"><a href="#【目标App】AccessibilityManager-sendAccessibilityEvent-AccessibilityEvent-event" class="headerlink" title="【目标App】AccessibilityManager.sendAccessibilityEvent(AccessibilityEvent event)"></a>【目标App】AccessibilityManager.sendAccessibilityEvent(AccessibilityEvent event)</h2><p>这里再次检查了辅助功能当前是否开启，之后就通过Binder进入AccessibilityManagerService【下文简称AMS，额，不要以为是ActivityManagerService】的世界了。</p><pre><code>public void sendAccessibilityEvent(AccessibilityEvent event) {    final IAccessibilityManager service;    final int userId;    synchronized (mLock) {        service = getServiceLocked();        if (service == null) {            return;        }        if (!mIsEnabled) {            Looper myLooper = Looper.myLooper();            if (myLooper == Looper.getMainLooper()) {                throw new IllegalStateException(                        &quot;Accessibility off. Did you forget to check that?&quot;);            } else {                Log.e(LOG_TAG, &quot;AccessibilityEvent sent with accessibility disabled&quot;);                return;            }        }        userId = mUserId;    }    boolean doRecycle = false;    try {        event.setEventTime(SystemClock.uptimeMillis());        long identityToken = Binder.clearCallingIdentity();        // 向AccessibilityManagerService发送AccessibilityEvent        doRecycle = service.sendAccessibilityEvent(event, userId);        Binder.restoreCallingIdentity(identityToken);        if (DEBUG) {            Log.i(LOG_TAG, event + &quot; sent&quot;);        }    } catch (RemoteException re) {        Log.e(LOG_TAG, &quot;Error during sending &quot; + event + &quot; &quot;, re);    } finally {        if (doRecycle) {            event.recycle();        }    }</code></pre><h2 id="【AMS】-AccessibilityManagerService-sendAccessibilityEvent-AccessibilityEvent-event-int-userId"><a href="#【AMS】-AccessibilityManagerService-sendAccessibilityEvent-AccessibilityEvent-event-int-userId" class="headerlink" title="【AMS】 AccessibilityManagerService.sendAccessibilityEvent(AccessibilityEvent event, int userId)"></a>【AMS】 AccessibilityManagerService.sendAccessibilityEvent(AccessibilityEvent event, int userId)</h2><p>在进行了一些检查和准备工作后，最后调用notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)准备开始分发。</p><pre><code>@Overridepublic boolean sendAccessibilityEvent(AccessibilityEvent event, int userId) {    synchronized (mLock) {        final int resolvedUserId = mSecurityPolicy                .resolveCallingUserIdEnforcingPermissionsLocked(userId);        if (resolvedUserId != mCurrentUserId) {            return true; // yes, recycle the event        }        if (mSecurityPolicy.canDispatchAccessibilityEventLocked(event)) {            mSecurityPolicy.updateActiveAndAccessibilityFocusedWindowLocked(event.getWindowId(),                    event.getSourceNodeId(), event.getEventType(), event.getAction());            mSecurityPolicy.updateEventSourceLocked(event);            // 开始分发AccessibilityEvent            notifyAccessibilityServicesDelayedLocked(event, false);            notifyAccessibilityServicesDelayedLocked(event, true);        }        if (mHasInputFilter &amp;&amp; mInputFilter != null) {            mMainHandler.obtainMessage(MainHandler.MSG_SEND_ACCESSIBILITY_EVENT_TO_INPUT_FILTER,                    AccessibilityEvent.obtain(event)).sendToTarget();        }        event.recycle();    }    return (OWN_PROCESS_ID != Binder.getCallingPid());}</code></pre><h2 id="【AMS】-AccessibilityManagerService-notifyAccessibilityServicesDelayedLocked-AccessibilityEvent-event-boolean-isDefault"><a href="#【AMS】-AccessibilityManagerService-notifyAccessibilityServicesDelayedLocked-AccessibilityEvent-event-boolean-isDefault" class="headerlink" title="【AMS】 AccessibilityManagerService.notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)"></a>【AMS】 AccessibilityManagerService.notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)</h2><p>UserState是AccessibilityManagerService一个内部类，在这个类里保存了一个用户当前安装了的、开启了的、已经建立连接的AccessibilityService列表等等信息。在初始化、安装/卸载应用、切换用户、开关辅助功能等等操作时，系统会对UserState的信息进行更新。mBoundServices中保存的就是当前已经启动了的Service列表，Service类也是AccessibilityManagerService的一个内部类，里面储存了从辅助App读取到的配置信息，即我们在辅助App的xml里配置的内容，并且Service类还会负责与各个AccessibilityService建立连接、进行通讯，管理着AccessibilityService的生命周期。此时会调用每个Service的notifyAccessibilityEvent(AccessibilityEvent event)进行事件的分发。</p><p>其中canDispatchEventToServiceLocked(Service service, AccessibilityEvent event)方法是用于判断该Service是否可以接收当前的AccessibilityEvent，即根据辅助App配置的需要接收的EventType和packageName等信息进行判断。</p><pre><code>private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault) {    try {        UserState state = getCurrentUserStateLocked();        for (int i = 0, count = state.mBoundServices.size(); i &lt; count; i++) {            Service service = state.mBoundServices.get(i);            if (service.mIsDefault == isDefault) {                // 辅助App接收该packageName和该EventType时才会分发                if (canDispatchEventToServiceLocked(service, event)) {                    service.notifyAccessibilityEvent(event);                }            }        }    } catch (IndexOutOfBoundsException oobe) {        // An out of bounds exception can happen if services are going away        // as the for loop is running. If that happens, just bail because        // there are no more services to notify.    }}</code></pre><h2 id="【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEvent-AccessibilityEvent-event"><a href="#【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEvent-AccessibilityEvent-event" class="headerlink" title="【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEvent(AccessibilityEvent event)"></a>【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEvent(AccessibilityEvent event)</h2><p>利用Service里定义的Handler把事件发出去，在handleMessage中进而调用了notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)方法。</p><pre><code>public void notifyAccessibilityEvent(AccessibilityEvent event) {        synchronized (mLock) {            final int eventType = event.getEventType();            // 复制当前的AccessibilityEvent            AccessibilityEvent newEvent = AccessibilityEvent.obtain(event);            Message message;            if ((mNotificationTimeout &gt; 0)                    &amp;&amp; (eventType != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED)) {                // Allow at most one pending event                final AccessibilityEvent oldEvent = mPendingEvents.get(eventType);                mPendingEvents.put(eventType, newEvent);                if (oldEvent != null) {                    mEventDispatchHandler.removeMessages(eventType);                    oldEvent.recycle();                }                message = mEventDispatchHandler.obtainMessage(eventType);            } else {                // Send all messages, bypassing mPendingEvents                message = mEventDispatchHandler.obtainMessage(eventType, newEvent);            }            mEventDispatchHandler.sendMessageDelayed(message, mNotificationTimeout);        }    }public Handler mEventDispatchHandler = new Handler(mMainHandler.getLooper()) {        @Override        public void handleMessage(Message message) {            final int eventType =  message.what;            AccessibilityEvent event = (AccessibilityEvent) message.obj;            notifyAccessibilityEventInternal(eventType, event);        }    };</code></pre><h2 id="【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEventInternal-int-eventType-AccessibilityEvent-event"><a href="#【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEventInternal-int-eventType-AccessibilityEvent-event" class="headerlink" title="【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)"></a>【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)</h2><p>该方法中的IAccessibilityServiceClient是AccessibilityService中的内部类IAccessibilityServiceClientWrapper，通过Binder调用了其onAccessibilityEvent(AccessibilityEvent event)方法。之后我们便转入了辅助App也就是接收辅助事件的App中。</p><pre><code>private void notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event) {        IAccessibilityServiceClient listener;        synchronized (mLock) {            listener = mServiceInterface;            // If the service died/was disabled while the message for dispatching            // the accessibility event was propagating the listener may be null.            if (listener == null) {                return;            }            if (event == null) {                event = mPendingEvents.get(eventType);                if (event == null) {                    return;                }                mPendingEvents.remove(eventType);            }            if (mSecurityPolicy.canRetrieveWindowContentLocked(this)) {                event.setConnectionId(mId);            } else {                event.setSource(null);            }            event.setSealed(true);        }        try {            // 分发给辅助App            listener.onAccessibilityEvent(event);            if (DEBUG) {                Slog.i(LOG_TAG, &quot;Event &quot; + event + &quot; sent to &quot; + listener);            }        } catch (RemoteException re) {            Slog.e(LOG_TAG, &quot;Error during sending &quot; + event + &quot; to &quot; + listener, re);        } finally {            event.recycle();        }    }</code></pre><h2 id="【辅助App】-AccessibilityService-IAccessibilityServiceClientWrapper-onAccessibilityEvent-AccessibilityEvent-event"><a href="#【辅助App】-AccessibilityService-IAccessibilityServiceClientWrapper-onAccessibilityEvent-AccessibilityEvent-event" class="headerlink" title="【辅助App】 AccessibilityService.IAccessibilityServiceClientWrapper.onAccessibilityEvent(AccessibilityEvent event)"></a>【辅助App】 AccessibilityService.IAccessibilityServiceClientWrapper.onAccessibilityEvent(AccessibilityEvent event)</h2><p>此时通过mCaller发送了message code为DO_ON_ACCESSIBILITY_EVENT的Message，mCaller是IAccessibilityServiceClientWrapper中持有的一个HandlerCaller，在IAccessibilityServiceClientWrapper的构造方法中通过mCaller = new HandlerCaller(context, looper, this, true /<em>asyncHandler</em>/)创建，其中第三个参数即HandlerCaller的Callback，因此最终会回调IAccessibilityServiceClientWrapper的executeMessage方法。</p><p>在此我们只看message code为DO_ON_ACCESSIBILITY_EVENT的实现，可以看到最后调用的是mCallback.onAccessibilityEvent(event)，这个mCallback是什么呢？在AccessibilityService里定义了一个接口Callbacks，IAccessibilityServiceClientWrapper中持有的这个Callbacks是由其构造方法传入的参数。而IAccessibilityServiceClientWrapper是在AccessibilityService的onBind(Intent intent)方法中生成了，其中Callbacks的onAccessibilityEvent(AccessibilityEvent event)方法实现非常简单，直接调用了AccessibilityService.this.onAccessibilityEvent(event)，这个也就是我们在辅助App中重写的onAccessibilityEvent(AccessibilityEvent event)方法了。</p><pre><code>public void onAccessibilityEvent(AccessibilityEvent event) {    Message message = mCaller.obtainMessageO(DO_ON_ACCESSIBILITY_EVENT, event);    mCaller.sendMessage(message);}public void executeMessage(Message message) {        switch (message.what) {            case DO_ON_ACCESSIBILITY_EVENT: {                AccessibilityEvent event = (AccessibilityEvent) message.obj;                if (event != null) {                    // 如果是设计UI方面的eventType会对一些缓存进行更新                    AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event);                    mCallback.onAccessibilityEvent(event);                    // Make sure the event is recycled.                    try {                        event.recycle();                    } catch (IllegalStateException ise) {                        /* ignore - best effort */                    }                }            } return;            ...// 其他实现省略        }    }@Overridepublic void onAccessibilityEvent(AccessibilityEvent event) {    AccessibilityService.this.onAccessibilityEvent(event);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，AccessibilityEvent便由目标App经由AccessibilityManagerService发送到了辅助App上，如果用图展示的话大致如下（图中省去了部分Handler的流程）：</p><p><a href="AccessibilityEvent.png">点击查看大图</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/04/17/accessibility-event/AccessibilityEvent.png" alt="Accessibility" title="">                </div>                <div class="image-caption">Accessibility</div>            </figure><h1 id="补遗"><a href="#补遗" class="headerlink" title="补遗"></a>补遗</h1><h2 id="目标App与AccessibilityManagerService的通讯"><a href="#目标App与AccessibilityManagerService的通讯" class="headerlink" title="目标App与AccessibilityManagerService的通讯"></a>目标App与AccessibilityManagerService的通讯</h2><p>其实目标App与AccessibilityManagerService之间除了在发送AccessibilityEvent时进行了通讯外，在第一次连接获取辅助服务开关状态以及开关状态发生变化时都会进行通讯。判断辅助服务是否开启的逻辑如下：</p><pre><code>public boolean isEnabled() {    synchronized (mLock) {        IAccessibilityManager service = getServiceLocked();        if (service == null) {            return false;        }        return mIsEnabled;    }}private  IAccessibilityManager getServiceLocked() {    if (mService == null) {        tryConnectToServiceLocked(null);    }    return mService;}private void tryConnectToServiceLocked(IAccessibilityManager service) {    if (service == null) {        IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE);        if (iBinder == null) {            return;        }        service = IAccessibilityManager.Stub.asInterface(iBinder);    }    try {        // 向AccessibilityManagerService添加client时会返回当前开关状态        final int stateFlags = service.addClient(mClient, mUserId);        setStateLocked(stateFlags);        mService = service;    } catch (RemoteException re) {        Log.e(LOG_TAG, &quot;AccessibilityManagerService is dead&quot;, re);    }}</code></pre><p>AccessibilityManager中用mIsEnabled变量标识当前辅助功能是否开启，如果当前已经和AccessibilityManagerService建立了联系则直接返回该标识，如果没有会尝试和AccessibilityManagerService联系，调用AccessibilityManagerService.addClient(mClient, mUserId)方法就能得到当前辅助功能的开关状态，之后通过setStateLocked(stateFlags)给mIsEnabled变量赋值。</p><pre><code>private void setStateLocked(int stateFlags) {    final boolean enabled = (stateFlags &amp; STATE_FLAG_ACCESSIBILITY_ENABLED) != 0;    final boolean touchExplorationEnabled =            (stateFlags &amp; STATE_FLAG_TOUCH_EXPLORATION_ENABLED) != 0;    final boolean highTextContrastEnabled =            (stateFlags &amp; STATE_FLAG_HIGH_TEXT_CONTRAST_ENABLED) != 0;    final boolean wasEnabled = mIsEnabled;    final boolean wasTouchExplorationEnabled = mIsTouchExplorationEnabled;    final boolean wasHighTextContrastEnabled = mIsHighTextContrastEnabled;    // Ensure listeners get current state from isZzzEnabled() calls.    mIsEnabled = enabled;    mIsTouchExplorationEnabled = touchExplorationEnabled;    mIsHighTextContrastEnabled = highTextContrastEnabled;    if (wasEnabled != enabled) {        mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_ACCESSIBILITY_STATE_CHANGED);    }    if (wasTouchExplorationEnabled != touchExplorationEnabled) {        mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_EXPLORATION_STATE_CHANGED);    }    if (wasHighTextContrastEnabled != highTextContrastEnabled) {        mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_HIGH_TEXT_CONTRAST_STATE_CHANGED);    }}</code></pre><p>除此之外还可以看到我们可以向AccessibilityManager注册一些AccessibilityStateChangeListener，当开关状态发生变化时我们能拿到相应的回调。</p><p>在调用AccessibilityManagerService.addClient(mClient, mUserId)时，目标App就向AccessibilityManagerService注册了自己，mClient代码如下：</p><pre><code>private final IAccessibilityManagerClient.Stub mClient =        new IAccessibilityManagerClient.Stub() {    public void setState(int state) {        mHandler.obtainMessage(MyHandler.MSG_SET_STATE, state, 0).sendToTarget();    }};</code></pre><p>当辅助功能开关变化时，AccessibilityManagerService会调用每个client的setState(int state)方法，通过Handler又调用了setStateLocked(state)方法修改了开关状态。</p><h2 id="第7步AccessibilityManagerService进行了哪些检查和准备"><a href="#第7步AccessibilityManagerService进行了哪些检查和准备" class="headerlink" title="第7步AccessibilityManagerService进行了哪些检查和准备"></a>第7步AccessibilityManagerService进行了哪些检查和准备</h2><p>系统不允许后台用户发送AccessibilityEvent，所以首先会检查处理后的UserId是否和当前UserId一样。实际使用中，多用户的情况并不多，所以我们基本无需考虑UserId的问题。</p><pre><code>public int resolveCallingUserIdEnforcingPermissionsLocked(int userId) {        final int callingUid = Binder.getCallingUid();        if (callingUid == 0                || callingUid == Process.SYSTEM_UID                || callingUid == Process.SHELL_UID) {            if (userId == UserHandle.USER_CURRENT                    || userId == UserHandle.USER_CURRENT_OR_SELF) {                return mCurrentUserId;            }            return resolveProfileParentLocked(userId);        }        final int callingUserId = UserHandle.getUserId(callingUid);        if (callingUserId == userId) {            return resolveProfileParentLocked(userId);        }        final int callingUserParentId = resolveProfileParentLocked(callingUserId);        if (callingUserParentId == mCurrentUserId &amp;&amp;                (userId == UserHandle.USER_CURRENT                        || userId == UserHandle.USER_CURRENT_OR_SELF)) {            return mCurrentUserId;        }        if (!hasPermission(Manifest.permission.INTERACT_ACROSS_USERS)                &amp;&amp; !hasPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL)) {            throw new SecurityException(&quot;Call from user &quot; + callingUserId + &quot; as user &quot;                    + userId + &quot; without permission INTERACT_ACROSS_USERS or &quot;                    + &quot;INTERACT_ACROSS_USERS_FULL not allowed.&quot;);        }        if (userId == UserHandle.USER_CURRENT                || userId == UserHandle.USER_CURRENT_OR_SELF) {            return mCurrentUserId;        }        throw new IllegalArgumentException(&quot;Calling user can be changed to only &quot;                + &quot;UserHandle.USER_CURRENT or UserHandle.USER_CURRENT_OR_SELF.&quot;);    }private int resolveProfileParentLocked(int userId) {        if (userId != mCurrentUserId) {            final long identity = Binder.clearCallingIdentity();            try {                UserInfo parent = mUserManager.getProfileParent(userId);                if (parent != null) {                    return parent.getUserHandle().getIdentifier();                }            } finally {                Binder.restoreCallingIdentity(identity);            }        }        return userId;    }</code></pre><p>之后会检查这个AccessibilityEvent能不能分发，见下面的代码，一部分EventType是必定可以分发的，其他的EventType会再检查Window的情况。</p><pre><code>private boolean canDispatchAccessibilityEventLocked(AccessibilityEvent event) {        final int eventType = event.getEventType();        switch (eventType) {            case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:            case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:            case AccessibilityEvent.TYPE_ANNOUNCEMENT:            case AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_START:            case AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_END:            case AccessibilityEvent.TYPE_GESTURE_DETECTION_START:            case AccessibilityEvent.TYPE_GESTURE_DETECTION_END:            case AccessibilityEvent.TYPE_TOUCH_INTERACTION_START:            case AccessibilityEvent.TYPE_TOUCH_INTERACTION_END:            case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:            case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:            case AccessibilityEvent.TYPE_ASSIST_READING_CONTEXT:            case AccessibilityEvent.TYPE_WINDOWS_CHANGED: {                return true;            }            default: {                return isRetrievalAllowingWindow(event.getWindowId());            }        }    }private boolean isRetrievalAllowingWindow(int windowId) {        // The system gets to interact with any window it wants.        if (Binder.getCallingUid() == Process.SYSTEM_UID) {            return true;        }        if (windowId == mActiveWindowId) {            return true;        }        return findWindowById(windowId) != null;    }</code></pre><p>这2项检查通过之后，就准备分发事件了，updateActiveAndAccessibilityFocusedWindowLocked方法主要更新了一些跟Window相关的东西，而updateEventSourceLocked方法则是会把不在RETRIEVAL_ALLOWING_EVENT_TYPES之中的AccessibilityEvent的source置为null。</p><pre><code>private static final int RETRIEVAL_ALLOWING_EVENT_TYPES =        AccessibilityEvent.TYPE_VIEW_CLICKED        | AccessibilityEvent.TYPE_VIEW_FOCUSED        | AccessibilityEvent.TYPE_VIEW_HOVER_ENTER        | AccessibilityEvent.TYPE_VIEW_HOVER_EXIT        | AccessibilityEvent.TYPE_VIEW_LONG_CLICKED        | AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED        | AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED        | AccessibilityEvent.TYPE_VIEW_SELECTED        | AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED        | AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED        | AccessibilityEvent.TYPE_VIEW_SCROLLED        | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED        | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED        | AccessibilityEvent.TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前关于辅助功能的使用的文章很多，但鲜有分析其具体实现的，本文基于Andoird 7.1.0_r7源码分析一下辅助事件是怎么分发的，只涉及事件的分发和辅助App的接收，之后有机会再讲一讲获取AccessibilityNodeInfo、进行操作等等的源码流程。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
      <category term="Accessibility" scheme="https://blog.darkness463.top/tags/Accessibility/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Java虚拟机(一)-GC</title>
    <link href="https://blog.darkness463.top/2017/03/30/Java-VM-GC/"/>
    <id>https://blog.darkness463.top/2017/03/30/Java-VM-GC/</id>
    <published>2017-03-30T07:00:00.000Z</published>
    <updated>2018-03-27T15:30:04.527Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前看《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书时，做了一些笔记，分享一下，还有几篇会陆续发上来。文中的东西基本都来自书中。</p><a id="more"></a><ul><li><p>判断对象是否存活</p><ul><li><p>引用计数算法（Reference Counting）</p><blockquote><p>给对象中添加一个引用计数器，当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是还不可能再被使用的。实现简单，判定效率高，但很难解决对象之间相互循环引用的问题。</p></blockquote></li><li><p>可达性分析算法（Reachability Analysis）</p><blockquote><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链项链时，则证明此对象是不可用的。</p></blockquote></li><li><p>Java中可作为GC Roots的对象包括下面几种：</p><blockquote><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ol></blockquote></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/03/30/Java-VM-GC/ReachabilityAnalysis.png" alt="可达性分析" title="">                </div>                <div class="image-caption">可达性分析</div>            </figure><ul><li><p>Java中引用关系</p><ul><li><p>强引用（Strong Reference）</p><blockquote><p>类似Object obj = new Object()的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></blockquote></li><li><p>软引用（Soft Reference）</p><blockquote><p>用来描述一些还有用但非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。</p></blockquote></li><li><p>弱引用（Weak Reference）</p><blockquote><p>用来描述非必需对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</p></blockquote></li><li><p>虚引用（Phantom Reference）</p><blockquote><p>也称幽灵引用或幻影引用，最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></blockquote></li></ul></li></ul><ul><li><p>finalize方法</p><blockquote><p>当对象进行可达性分析后发现没有与GC Roots相连接的引用链，将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，则视为“没有必要执行”。【因此finalize()方法只会被执行一次】</p><p>执行finalize()方法时，会将该对象放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行（触发finalize()方法但不承诺会等待它运行结束，防止finalize()方法执行缓慢导致阻塞）。稍后GC会对F-Queue中的对象进行二次标记，如果对象在finalize()方法中使自己与任一对象建立关联，将被移除出“即将回收”的集合，否则将真正回收。但注意finalize()方法只会执行一次。</p><p>不推荐使用。</p></blockquote></li></ul><ul><li><p>垃圾收集算法</p><ul><li><p>标记-清除（Mark-Sweep）算法</p><blockquote><p>先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>不足： </p><ol><li>效率问题，标记和清除两个过程的效率都不高； </li><li>空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol></blockquote></li><li><p>复制（Copying）算法</p><blockquote><p>将内存划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>为减少内存的浪费，实际按8：1：1的比例分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，然后清理掉Eden和刚才用过的Survivor空间。当另一块Survivor空间不足存放Eden和Survivor中存活的对象时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。</p></blockquote></li><li><p>标记-整理（Mark-Compact）算法</p><blockquote><p>标记过程仍然与“标记-清除”算法一样，但不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>老年代一般采用该种算法。</p></blockquote></li><li><p>分代收集（Generational Collection）算法</p><blockquote><p>当前商用虚拟机的垃圾收集都采用分代收集算法。一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p></blockquote></li></ul></li></ul><ul><li><p>垃圾收集器</p><ul><li><p>Serial收集器</p><blockquote><p>单线程的收集器，进行垃圾收集时，必须暂停其他所以的工作线程，直到它收集结束（Stop The World）。复制算法。</p></blockquote></li><li><p>ParNew收集器</p><blockquote><p>Serial收集器的多线程版本，除使用多条线程进行垃圾收集外其余与Serial收集器一样。复制算法。</p></blockquote></li><li><p>Parallel Scavenge收集器</p><blockquote><p>复制算法，并行的多线程收集器。“吞吐量优先”，达到一个可控制的吞吐量（Throughput），吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p></blockquote></li><li><p>Serial Old收集器</p><blockquote><p>单线程，“标记-整理”算法。</p></blockquote></li><li><p>Parallel Old收集器</p><blockquote><p>多线程，“标记-整理”算法。</p></blockquote></li><li><p>CMS收集器（Concurrent Mark Sweep）</p><blockquote><p>以获取最短回收停顿时间为目标的收集器。“标记-清除”算法。整个过程分为4个步骤，耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。</p><ol><li><p>初始标记（CMS initial mark）</p><p> 需stop the world，仅仅标记一下GC Roots能直接关联到的对象，速度很快。</p></li><li><p>并发标记（CMS concurrent mark）</p><p> 进行GC Roots Tracing。</p></li><li><p>重新标记（CMS remark）</p><p> 需stop the world，修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。</p></li><li>并发清除（CMS concurrent sweep）</li></ol></blockquote></li><li><p>G1收集器（Garbage-First）</p><blockquote><p>特点：并行、并发、分代收集、整体“标记-整理”局部（两个Region之间）“复制”算法、可预测的停顿。将整个Java堆划分为多个大小相等的独立区域（Region），跟着各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。步骤：初始标记（Initial Marking）、并发标记（Concurrent Marking）、最终标记（Final Marking）、筛选回收（Live Data Counting and Evacuation）</p></blockquote></li></ul></li></ul><ul><li><p>内存分配与回收策略</p><ul><li><p>对象优先在Eden分配</p><blockquote><p>大多数情况下，对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p></blockquote></li><li><p>大对象直接进入老年代</p><blockquote><p>大对象即需要大量连续内存空间的Java对象，如很长的字符串和数组。</p></blockquote></li><li><p>长期存活的对象将进入老年代</p><blockquote><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），将会被晋升到老年代中。</p></blockquote></li><li><p>动态对象年龄判断</p><blockquote><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到设置要求的年龄。</p></blockquote></li><li><p>空间分配担保</p><blockquote><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，如果小于，或者HandlePromotionFailure设置不允许冒险，则改为进行一次Full GC。</p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久以前看《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书时，做了一些笔记，分享一下，还有几篇会陆续发上来。文中的东西基本都来自书中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.darkness463.top/tags/Java/"/>
    
      <category term="GC" scheme="https://blog.darkness463.top/tags/GC/"/>
    
  </entry>
  
</feed>
