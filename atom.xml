<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>变猴旅程</title>
  
  <subtitle>从人变猴的历程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.darkness463.top/"/>
  <updated>2018-09-30T09:44:13.158Z</updated>
  <id>https://blog.darkness463.top/</id>
  
  <author>
    <name>Darkness463</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android多开检测的另一个思路</title>
    <link href="https://blog.darkness463.top/2018/09/30/Android-Virtual-Check-Plus/"/>
    <id>https://blog.darkness463.top/2018/09/30/Android-Virtual-Check-Plus/</id>
    <published>2018-09-30T09:42:17.000Z</published>
    <updated>2018-09-30T09:44:13.158Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了篇<a href="https://blog.darkness463.top/2018/05/04/Android-Virtual-Check/">检测多开的文章</a>后，经过几个月的时间，基本上都已经被各多开软件绕过了。最近无意中发现了一些新特征，在特定环境下可以用来检测多开环境，特此来分享一下。</p><a id="more"></a><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>某次在多开环境下运行demo，发现动态库加载失败了，错误信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dlopen failed: <span class="string">"/data/app/【手动打码】/lib/arm64/【手动打码】.so"</span> is <span class="number">64</span>-bit instead of <span class="number">32</span>-bit</span><br><span class="line"> at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="number">1016</span>)</span><br><span class="line"> at java.lang.System.loadLibrary(System.java:<span class="number">1660</span>)</span><br><span class="line"> ... 省略</span><br></pre></td></tr></table></figure><p>这个错误没什么好多说的，很明显，动态库是64位的而App运行在32位下，因此加载失败了。其实之前也看到过类似的现象，本应在64位下运行的App到多开环境下就变为32位环境了，只是之前并没有去深究，这次遇到后仔细想了一下，在某些情况下可以用来检测多开环境。</p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>对于64位的手机，会启动2个zygote，<code>zygote</code>和<code>zygote64</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root  670 1 4359784  27292 poll_schedule_timeout 7f7b47058c S zygote64</span><br><span class="line">root  671 1 1696576  11120 poll_schedule_timeout eb823684   S zygote</span><br></pre></td></tr></table></figure><p>以64位运行的App将由<code>zygote64</code> fork而来，而以32位运行的App将由<code>zygote</code> fork出来。可以从下面的代码看出来，<code>ZygoteProcess.java</code>中，<code>startViaZygote</code>方法会通过<code>openZygoteSocketIfNeeded</code>方法选择合适的zygote。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] extraArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    Preconditions.checkState(Thread.holdsLock(mLock), <span class="string">"ZygoteProcess lock not held"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The primary zygote didn't match. Try the secondary.</span></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何确定App是以64位还是以32位运行呢？这就取决于动态库，如果只有32位的动态库（armeabi、armeabi-v7a），那么就会以32位运行，如果有64位的动态库（arm64-v8a），那么就以64位运行，不存在动态库则默认以64位运行。</p><p>如何证明？我们写3个demo来实际看一下。</p><ul><li>demo1: 包名<code>top.darkness463.whichzygote</code>，不加动态库。</li><li>demo2: 包名<code>top.darkness463.zygote32</code>，加一个<code>armeabi</code>动态库。</li><li>demo3: 包名<code>top.darkness463.zygote64</code>，加<code>armeabi</code>和<code>arm64-v8a</code>动态库。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root     670    1   4359784  27692 poll_schedule_timeout 7f7b47058c S zygote64</span><br><span class="line">root     671    1   1696576  11416 poll_schedule_timeout eb823684   S zygote</span><br><span class="line">u0_a177  9878   670 4456080  63412 SyS_epoll_wait        7f7b47046c S top.darkness463.whichzygote</span><br><span class="line">u0_a180  13690  671 1791700  58664 SyS_epoll_wait        eb8234ac   S top.darkness463.zygote32</span><br><span class="line">u0_a179  13871  670 4456524  64716 SyS_epoll_wait        7f7b47046c S top.darkness463.zygote64</span><br></pre></td></tr></table></figure><p>可以看到，demo1和demo3的父进程是<code>zygote64</code>，而demo2的父进程是<code>zygote</code>。</p><p>那么为何在多开环境下会出现动态库加载失败的情况呢？原因就在于我那个demo有<code>arm64-v8a</code>的动态库，在安装时，系统会把该64位动态库拷到<code>/data/app/【包名】/lib/arm64/</code>下，然后那款多开软件只有32位的动态库，因此是以32位运行的，此时去<code>/data/app/【包名】/lib/arm64/</code>路径下加载64位的动态库必然导致失败。</p><p>打开思路的话，这也可以是一种检测多开环境的方式。</p><h1 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h1><p>其实与其说这是检测多开的方法，倒不如说这是多开软件的bug。看了几款排名靠前的多开软件，都只有32位的动态库，但它们完全可以加上64位动态库来避免这个问题。</p><p>另外，为了减小apk的体积，绝大多数App只会添加<code>armeabi</code>平台，而不会添加<code>arm64-v8a</code>平台的动态库，所以这种检测方法在很多App上本身就是不成立的。</p><h1 id="补遗"><a href="#补遗" class="headerlink" title="补遗"></a>补遗</h1><p>之前那篇文章提到过一个通过<code>/proc/self/maps</code>来检测多开的方式，当时提到这个方法的缺点是需要收集所有多开App的包名，但真正搞事的人很可能不会拿市面上的多开软件来作恶，他们可能利用开源的多开软件改成乱七八糟的包名，之前我甚至见过命名成<code>com.tencent.qqlite</code>来进行伪装的。之后我又做了一些工作，也和大家分享一下。</p><p>思路还是从<code>/proc/self/maps</code>中的动态库出发。在这里直接给出结论了不再详细讨论了。</p><ul><li><code>/proc/self/maps</code>中出现包含 <code>/vbox/data/</code>、 <code>/shadow/data/</code>、 <code>/virtual/data/</code>的动态库，则运行在多开环境下。主要是因为很多多开软件都是基于开源或者抄来抄去的，所有目录名无外乎这么几种，但不排除会有多开软件修改掉名字的情况。</li><li>从<code>/proc/self/maps</code>加载的动态库路径我们可以解析到包名，如果自己的App并不会加载其他App的动态库（第三方登录可能会把其他App的动态库加载进去）的话，出现非自己包名的动态库可能疑似运行在多开环境下。服务端可以建立一套自动解析包名 + 添加到黑名单的流程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了篇&lt;a href=&quot;https://blog.darkness463.top/2018/05/04/Android-Virtual-Check/&quot;&gt;检测多开的文章&lt;/a&gt;后，经过几个月的时间，基本上都已经被各多开软件绕过了。最近无意中发现了一些新特征，在特定环境下可以用来检测多开环境，特此来分享一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>基于mongoose的C++ Http Server的“坑”与“坑”</title>
    <link href="https://blog.darkness463.top/2018/07/25/cpp-http-server-mongoose/"/>
    <id>https://blog.darkness463.top/2018/07/25/cpp-http-server-mongoose/</id>
    <published>2018-07-25T09:23:07.000Z</published>
    <updated>2018-07-25T09:26:49.765Z</updated>
    
    <content type="html"><![CDATA[<p>最近有个奇葩的需求，需要用C++去实现一个Http Server。用Java或者其他语言去实现Http Server是一件很简单的事，但用C++去实现我就闻所未闻了（当然主要是我也没写过C++嘛）。于是去搜索了一把，不少人推荐<a href="https://github.com/cesanta/mongoose" target="_blank" rel="noopener">mongoose</a>，在实际使用中遇到了不少的坑。</p><a id="more"></a><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>使用mongoose只需要将mongoose.h和mongoose.c引入即可。下面通过几个简单的例子了解一下mongoose的使用及工作方式。</p><h2 id="简单的Web-Server"><a href="#简单的Web-Server" class="headerlink" title="简单的Web Server"></a>简单的Web Server</h2><p>这是官方给的<a href="https://github.com/cesanta/mongoose/tree/master/examples/simplest_web_server" target="_blank" rel="noopener">示例</a>。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mongoose.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *s_http_port = <span class="string">"8000"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_serve_http_opts</span> <span class="title">s_http_server_opts</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ev_handler</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_REQUEST) &#123;</span><br><span class="line">    mg_serve_http(nc, (struct http_message *) p, s_http_server_opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> <span class="title">mgr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">nc</span>;</span></span><br><span class="line"></span><br><span class="line">  mg_mgr_init(&amp;mgr, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Starting web server on port %s\n"</span>, s_http_port);</span><br><span class="line">  nc = mg_bind(&amp;mgr, s_http_port, ev_handler);</span><br><span class="line">  <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to create listener\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up HTTP server parameters</span></span><br><span class="line">  mg_set_protocol_http_websocket(nc);</span><br><span class="line">  s_http_server_opts.document_root = <span class="string">"."</span>;  <span class="comment">// Serve current directory</span></span><br><span class="line">  s_http_server_opts.enable_directory_listing = <span class="string">"yes"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    mg_mgr_poll(&amp;mgr, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mg_mgr_free(&amp;mgr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有几个关键的结构体。<br><code>mg_mgr</code>: 用于管理连接、事件等的Manager。<br><code>mg_connection</code>: 单个连接，保存了连接信息。</p><p>从官方给的例子我们可以了解主要用法步骤：</p><ol><li>调用<code>mg_mgr_init</code>进行初始化。</li><li>调用<code>mg_bind</code>，第2个参数为需要监听的端口号，第3个参数为处理请求的handler。</li><li>调用<code>mg_set_protocol_http_websocket</code>将上一步返回的<code>mg_connection</code>与内建的http handler绑定。这样我们的handler才能收到http事件。</li><li>通过一直调用<code>mg_mgr_poll</code>接收请求。</li></ol><p>接下来我们看一下例子中的handler。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ev_handler</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_REQUEST) &#123;</span><br><span class="line">    mg_serve_http(nc, (struct http_message *) p, s_http_server_opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>handler有3个参数，第1个参数是当前连接的<code>mg_connection</code>结构体，第2个参数是事件类型，第3个参数为事件的数据。</p><p>常用事件类型包含以下几种：</p><ul><li><code>MG_EV_ACCEPT</code>: 新连接被接受。</li><li><code>MG_EV_HTTP_REQUEST</code>: 收到http请求，此时第3个参数可以将其强转为<code>http_message</code>结构体使用，包含了method、header、body等等信息。</li><li><code>MG_EV_CLOSE</code>: 连接关闭</li></ul><p>例子中在收到<code>MG_EV_HTTP_REQUEST</code>事件时，调用了<code>mg_serve_http</code>，该方法会根据设置的根路径寻找html等资源。</p><h2 id="RESTful-Server"><a href="#RESTful-Server" class="headerlink" title="RESTful Server"></a>RESTful Server</h2><p>这个<a href="https://github.com/cesanta/mongoose/blob/master/examples/restful_server/restful_server.c" target="_blank" rel="noopener">例子</a>也是来自于官方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mongoose.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *s_http_port = <span class="string">"8000"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_serve_http_opts</span> <span class="title">s_http_server_opts</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_sum_call</span><span class="params">(struct mg_connection *nc, struct http_message *hm)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> n1[<span class="number">100</span>], n2[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">double</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get form variables */</span></span><br><span class="line">  mg_get_http_var(&amp;hm-&gt;body, <span class="string">"n1"</span>, n1, <span class="keyword">sizeof</span>(n1));</span><br><span class="line">  mg_get_http_var(&amp;hm-&gt;body, <span class="string">"n2"</span>, n2, <span class="keyword">sizeof</span>(n2));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send headers */</span></span><br><span class="line">  mg_printf(nc, <span class="string">"%s"</span>, <span class="string">"HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute the result and send it back as a JSON object */</span></span><br><span class="line">  result = strtod(n1, <span class="literal">NULL</span>) + strtod(n2, <span class="literal">NULL</span>);</span><br><span class="line">  mg_printf_http_chunk(nc, <span class="string">"&#123; \"result\": %lf &#125;"</span>, result);</span><br><span class="line">  mg_send_http_chunk(nc, <span class="string">""</span>, <span class="number">0</span>); <span class="comment">/* Send empty chunk, the end of response */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ev_handler</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *ev_data)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">http_message</span> *<span class="title">hm</span> = (<span class="title">struct</span> <span class="title">http_message</span> *) <span class="title">ev_data</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ev) &#123;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_HTTP_REQUEST:</span><br><span class="line">      <span class="keyword">if</span> (mg_vcmp(&amp;hm-&gt;uri, <span class="string">"/api/v1/sum"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        handle_sum_call(nc, hm); <span class="comment">/* Handle RESTful call */</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mg_vcmp(&amp;hm-&gt;uri, <span class="string">"/printcontent"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, hm-&gt;body.p,</span><br><span class="line">               <span class="keyword">sizeof</span>(buf) - <span class="number">1</span> &lt; hm-&gt;body.len ? <span class="keyword">sizeof</span>(buf) - <span class="number">1</span> : hm-&gt;body.len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mg_serve_http(nc, hm, s_http_server_opts); <span class="comment">/* Serve static content */</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> <span class="title">mgr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">nc</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_bind_opts</span> <span class="title">bind_opts</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> *cp;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *err_str;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MG_ENABLE_SSL</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ssl_cert = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  mg_mgr_init(&amp;mgr, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Use current binary directory as document root */</span></span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">0</span> &amp;&amp; ((cp = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], DIRSEP)) != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    *cp = <span class="string">'\0'</span>;</span><br><span class="line">    s_http_server_opts.document_root = argv[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process command line options to customize HTTP server */</span></span><br><span class="line">  <span class="comment">// 省略这部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set HTTP server options */</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;bind_opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(bind_opts));</span><br><span class="line">  bind_opts.error_string = &amp;err_str;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MG_ENABLE_SSL</span></span><br><span class="line">  <span class="keyword">if</span> (ssl_cert != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    bind_opts.ssl_cert = ssl_cert;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  nc = mg_bind_opt(&amp;mgr, s_http_port, ev_handler, bind_opts);</span><br><span class="line">  <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error starting server on port %s: %s\n"</span>, s_http_port,</span><br><span class="line">            *bind_opts.error_string);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mg_set_protocol_http_websocket(nc);</span><br><span class="line">  s_http_server_opts.enable_directory_listing = <span class="string">"yes"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Starting RESTful server on port %s, serving %s\n"</span>, s_http_port,</span><br><span class="line">         s_http_server_opts.document_root);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    mg_mgr_poll(&amp;mgr, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mg_mgr_free(&amp;mgr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要区别在于处理<code>MG_EV_HTTP_REQUEST</code>时，根据请求的uri的不同进行不同的处理。示例中请求<code>/api/v1/sum</code>时，调用了<code>handle_sum_call</code>进行处理。</p><p>从示例的<code>handle_sum_call</code>方法我们可以了解返回结果基本步骤。</p><ol><li>根据业务逻辑得到需要返回的字符串。</li><li>调用<code>mg_printf(nc, &quot;%s&quot;, &quot;HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n&quot;);</code>回写headers。</li><li>调用<code>mg_printf_http_chunk(nc, result);</code>回写response，其中<code>result</code>即第1步得到的要返回的字符串。</li><li>调用<code>mg_send_http_chunk(nc, &quot;&quot;, 0);</code>作为结束。</li></ol><h2 id="请求信息的获取"><a href="#请求信息的获取" class="headerlink" title="请求信息的获取"></a>请求信息的获取</h2><p>处理具体业务时，我们可能需要根据请求的header、method、body等进行相应的处理。前文提到我们在收到<code>MG_EV_HTTP_REQUEST</code>类型的回调时，可以将第3个参数转为<code>http_message</code>结构体，其定义如下，可以结合官方的注释了解其含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">http_message</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">message</span>;</span> <span class="comment">/* Whole message: request line + headers + body */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">body</span>;</span>    <span class="comment">/* Message body. 0-length for requests with no body */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HTTP Request line (or HTTP response line) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">method</span>;</span> <span class="comment">/* "GET" */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">uri</span>;</span>    <span class="comment">/* "/my_file.html" */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">proto</span>;</span>  <span class="comment">/* "HTTP/1.1" -- for both request and response */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For responses, code and response status message are set */</span></span><br><span class="line">    <span class="keyword">int</span> resp_code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">resp_status_msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Query-string part of the URI. For example, for HTTP request</span></span><br><span class="line"><span class="comment">     *    GET /foo/bar?param1=val1&amp;param2=val2</span></span><br><span class="line"><span class="comment">     *    |    uri    |     query_string     |</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that question mark character doesn't belong neither to the uri,</span></span><br><span class="line"><span class="comment">     * nor to the query_string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">query_string</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Headers */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">header_names</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">header_values</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中每一个属性都是<code>mg_str</code>结构体，其定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p; <span class="comment">/* Memory chunk pointer */</span></span><br><span class="line">    <span class="keyword">size_t</span> len;    <span class="comment">/* Memory chunk length */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，<code>mg_str</code>实际就是存了起始地址和长度，所有我们从相应地址开始截取指定长度就是对于的属性内容。我们可以用类似下面这种方式获取相应属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> uri = <span class="built_in">std</span>::<span class="built_in">string</span>(http_req-&gt;uri.p, http_req-&gt;uri.len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> body = <span class="built_in">std</span>::<span class="built_in">string</span>(http_req-&gt;body.p, http_req-&gt;body.len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> method = <span class="built_in">std</span>::<span class="built_in">string</span>(http_req-&gt;method.p, http_req-&gt;method.len);</span><br></pre></td></tr></table></figure><p>headers的获取类似，header的key和value分别存放在<code>header_names</code>和<code>header_values</code>2个数组中，数组的长度<code>MG_MAX_HTTP_HEADERS</code>默认值为40，因此最大只支持40个header，当然我们可以自行修改该值。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>前文已经介绍了mongoose的简单使用了，但都是单线程的方式，QPS必然很难上去。mongoose也能支持1个IO线程、N个工作线程的模式。我们还是先来看一下<a href="https://github.com/cesanta/mongoose/blob/master/examples/multithreaded" target="_blank" rel="noopener">官方示例</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mongoose.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sig_atomic_t</span> s_received_signal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *s_http_port = <span class="string">"8000"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_num_worker_threads = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> s_next_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">signal_handler</span><span class="params">(<span class="keyword">int</span> sig_num)</span> </span>&#123;</span><br><span class="line">  signal(sig_num, signal_handler);</span><br><span class="line">  s_received_signal = sig_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_serve_http_opts</span> <span class="title">s_http_server_opts</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sock_t</span> sock[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// This info is passed to the worker thread</span></span><br><span class="line"><span class="comment">// 用于IO线程向工作线程发送请求</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_request</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> conn_id;  <span class="comment">// needed to identify the connection where to send the reply</span></span><br><span class="line">  <span class="comment">// optionally, more data that could be required by worker </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This info is passed by the worker thread to mg_broadcast</span></span><br><span class="line"><span class="comment">// 用于工作线程向IO线程返回结果</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_result</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> conn_id;</span><br><span class="line">  <span class="keyword">int</span> sleep_time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行在IO线程，用于回写结果</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_work_complete</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *ev_data)</span> </span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>) ev;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (c = mg_next(nc-&gt;mgr, <span class="literal">NULL</span>); c != <span class="literal">NULL</span>; c = mg_next(nc-&gt;mgr, c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;user_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">work_result</span> *<span class="title">res</span> = (<span class="title">struct</span> <span class="title">work_result</span> *)<span class="title">ev_data</span>;</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)c-&gt;user_data == res-&gt;conn_id) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(s, <span class="string">"conn_id:%lu sleep:%d"</span>, res-&gt;conn_id, res-&gt;sleep_time);</span><br><span class="line">        mg_send_head(c, <span class="number">200</span>, <span class="built_in">strlen</span>(s), <span class="string">"Content-Type: text/plain"</span>);</span><br><span class="line">        mg_printf(c, <span class="string">"%s"</span>, s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker_thread_proc</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> *<span class="title">mgr</span> = (<span class="title">struct</span> <span class="title">mg_mgr</span> *) <span class="title">param</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_request</span> <span class="title">req</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (s_received_signal == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (read(sock[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req)) &lt; <span class="number">0</span>)</span><br><span class="line">      perror(<span class="string">"Reading worker sock"</span>);</span><br><span class="line">    <span class="keyword">int</span> r = rand() % <span class="number">10</span>;</span><br><span class="line">    sleep(r);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_result</span> <span class="title">res</span> = &#123;</span>req.conn_id, r&#125;;</span><br><span class="line">    mg_broadcast(mgr, on_work_complete, (<span class="keyword">void</span> *)&amp;res, <span class="keyword">sizeof</span>(res));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ev_handler</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *ev_data)</span> </span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>) nc;</span><br><span class="line">  (<span class="keyword">void</span>) ev_data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span> (ev) &#123;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_ACCEPT:</span><br><span class="line">    <span class="comment">// 给连接设置一个id，用于后面IO线程回写结果找到对应的id回写。</span></span><br><span class="line">      nc-&gt;user_data = (<span class="keyword">void</span> *)++s_next_id;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_HTTP_REQUEST: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">work_request</span> <span class="title">req</span> = &#123;</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)nc-&gt;user_data&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (write(sock[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">"Writing worker sock"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_CLOSE: &#123;</span><br><span class="line">      <span class="keyword">if</span> (nc-&gt;user_data) nc-&gt;user_data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> <span class="title">mgr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">nc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起一对socket，用于IO线程向工作线程发送请求</span></span><br><span class="line">  <span class="keyword">if</span> (mg_socketpair(sock, SOCK_STREAM) == <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"Opening socket pair"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  signal(SIGTERM, signal_handler);</span><br><span class="line">  signal(SIGINT, signal_handler);</span><br><span class="line"></span><br><span class="line">  mg_mgr_init(&amp;mgr, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  nc = mg_bind(&amp;mgr, s_http_port, ev_handler);</span><br><span class="line">  <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to create listener\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mg_set_protocol_http_websocket(nc);</span><br><span class="line">  s_http_server_opts.document_root = <span class="string">"."</span>;  <span class="comment">// Serve current directory</span></span><br><span class="line">  s_http_server_opts.enable_directory_listing = <span class="string">"no"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s_num_worker_threads; i++) &#123;</span><br><span class="line">    mg_start_thread(worker_thread_proc, &amp;mgr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Started on port %s\n"</span>, s_http_port);</span><br><span class="line">  <span class="keyword">while</span> (s_received_signal == <span class="number">0</span>) &#123;</span><br><span class="line">    mg_mgr_poll(&amp;mgr, <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mg_mgr_free(&amp;mgr);</span><br><span class="line"></span><br><span class="line">  closesocket(sock[<span class="number">0</span>]);</span><br><span class="line">  closesocket(sock[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，流程是IO线程收到请求后，将请求通过socket发往工作线程，工作线程处理完后，通过<code>mg_broadcast</code>方法返回IO线程，mongoose内部也有一对socket用于工作线程向IO线程通信，IO线程收到后向对应的连接回写结果。</p><p>我们一个一个关键点来看。</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mg_socketpair(sock, SOCK_STREAM) == <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"Opening socket pair"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>mg_socketpair</code>方法开启一对socket，如前文所述，这对socket是用于IO线程向工作线程发送请求的。而工作线程向IO线程返回结果的socket不需要我们操心，mongoose帮我们实现了。<br>示例中定义了<code>work_request</code>和<code>work_result</code>2个结构体用于传输请求和结果，我们可以根据业务需要修改这2个结构体，但需要注意序列化的问题。</p><p>另外这里有个隐藏的坑。mongoose帮我们实现的socket利用了其定义的<code>ctl_msg</code>结构体进行传输。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_msg</span> &#123;</span></span><br><span class="line">    <span class="keyword">mg_event_handler_t</span> callback;</span><br><span class="line">    <span class="keyword">char</span> message[MG_CTL_MSG_MESSAGE_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>MG_CTL_MSG_MESSAGE_SIZE</code>默认值是8192，因此如果你的返回结果超过8k会有问题，需要将该值调大。</p><p>如果不想用socket从IO线程向工作线程发请求的话，我们也可以使用队列之类的，IO线程将请求往队列扔，工作线程一直从队列读请求。这里就不写具体实现了。</p><h2 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s_num_worker_threads; i++) &#123;</span><br><span class="line">    mg_start_thread(worker_thread_proc, &amp;mgr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中这部分代码即开启工作线程，我们可以根据自己的需要启动任意数量的工作线程。需要注意的是我们要将<code>MG_ENABLE_THREADS</code>的值改为1，否则<code>mg_start_thread</code>是无法调用的。</p><p>示例中的工作线程的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker_thread_proc</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> *<span class="title">mgr</span> = (<span class="title">struct</span> <span class="title">mg_mgr</span> *) <span class="title">param</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_request</span> <span class="title">req</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (s_received_signal == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (read(sock[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req)) &lt; <span class="number">0</span>)</span><br><span class="line">      perror(<span class="string">"Reading worker sock"</span>);</span><br><span class="line">    <span class="keyword">int</span> r = rand() % <span class="number">10</span>;</span><br><span class="line">    sleep(r);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_result</span> <span class="title">res</span> = &#123;</span>req.conn_id, r&#125;;</span><br><span class="line">    mg_broadcast(mgr, on_work_complete, (<span class="keyword">void</span> *)&amp;res, <span class="keyword">sizeof</span>(res));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>read</code>把<code>work_request</code>读出来，处理完后调用<code>mg_broadcast</code>将<code>work_result</code>返回IO线程，其中<code>on_work_complete</code>是返回IO线程后需要执行的方法。上节已经提到了，需要注意一下返回长度的问题。</p><h2 id="IO线程（接收请求）"><a href="#IO线程（接收请求）" class="headerlink" title="IO线程（接收请求）"></a>IO线程（接收请求）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ev_handler</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *ev_data)</span> </span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>) nc;</span><br><span class="line">  (<span class="keyword">void</span>) ev_data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span> (ev) &#123;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_ACCEPT:</span><br><span class="line">      nc-&gt;user_data = (<span class="keyword">void</span> *)++s_next_id;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_HTTP_REQUEST: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">work_request</span> <span class="title">req</span> = &#123;</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)nc-&gt;user_data&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (write(sock[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">"Writing worker sock"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_CLOSE: &#123;</span><br><span class="line">      <span class="keyword">if</span> (nc-&gt;user_data) nc-&gt;user_data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>MG_EV_ACCEPT</code>事件时，为<code>mg_connection</code>的<code>user_data</code>赋一个id，之后需要根据这个id确定向哪个连接回写结果。<code>MG_EV_CLOSE</code>事件时将该id置空。</p><p>而在<code>MG_EV_HTTP_REQUEST</code>时，通过<code>write</code>方法将封装的<code>work_request</code>向socket写。这样便能被上一节中的工作线程从socket中读到。</p><h2 id="IO线程（返回结果）"><a href="#IO线程（返回结果）" class="headerlink" title="IO线程（返回结果）"></a>IO线程（返回结果）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_work_complete</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *ev_data)</span> </span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>) ev;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (c = mg_next(nc-&gt;mgr, <span class="literal">NULL</span>); c != <span class="literal">NULL</span>; c = mg_next(nc-&gt;mgr, c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;user_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">work_result</span> *<span class="title">res</span> = (<span class="title">struct</span> <span class="title">work_result</span> *)<span class="title">ev_data</span>;</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)c-&gt;user_data == res-&gt;conn_id) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(s, <span class="string">"conn_id:%lu sleep:%d"</span>, res-&gt;conn_id, res-&gt;sleep_time);</span><br><span class="line">        mg_send_head(c, <span class="number">200</span>, <span class="built_in">strlen</span>(s), <span class="string">"Content-Type: text/plain"</span>);</span><br><span class="line">        mg_printf(c, <span class="string">"%s"</span>, s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑是遍历所有的连接，找出id相同的连接（即上一节提到的<code>MG_EV_ACCEPT</code>事件时设置的id），然后向改连接回写结果。</p><p>这里示例的实现我觉得有点问题，我们看一下mongoose中是如何回调<code>on_work_complete</code>方法的。前文提到mongoose中也有一对socket，用于工作线程向IO线程发送结果，结果是在<code>mg_mgr_handle_ctl_sock</code>方法中取出来的，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mg_mgr_handle_ctl_sock</span><span class="params">(struct mg_mgr *mgr)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ctl_msg</span> <span class="title">ctl_msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len =</span><br><span class="line">            (<span class="keyword">int</span>) MG_RECV_FUNC(mgr-&gt;ctl[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;ctl_msg, <span class="keyword">sizeof</span>(ctl_msg), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">size_t</span> dummy = MG_SEND_FUNC(mgr-&gt;ctl[<span class="number">1</span>], ctl_msg.message, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    DBG((<span class="string">"read %d from ctl socket"</span>, len));</span><br><span class="line">    (<span class="keyword">void</span>) dummy; <span class="comment">/* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(ctl_msg.callback) &amp;&amp; ctl_msg.callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">nc</span>;</span></span><br><span class="line">        <span class="keyword">for</span> (nc = mg_next(mgr, <span class="literal">NULL</span>); nc != <span class="literal">NULL</span>; nc = mg_next(mgr, nc)) &#123;</span><br><span class="line">            ctl_msg.callback(nc, MG_EV_POLL,</span><br><span class="line">                             ctl_msg.message MG_UD_ARG(nc-&gt;user_data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以清楚地看到，mongoose已经将所有的连接遍历一次了，并且会将每个连接当参数执行回调的方法（即<code>ctl_msg.callback(nc, MG_EV_POLL, ctl_msg.message MG_UD_ARG(nc-&gt;user_data));</code>）。所有我理解在<code>on_work_complete</code>中我们没必要再遍历一次了，只需要判断传过来的<code>mg_connection</code>是不是我们需要的那个连接，对正确的那个连接回写即可。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>在16核 16G内存的机器上进行了一下压测。同样都以20个并发压（恕我直言，并发太高这个框架根本扛不住）。压了3个不同的版本，这三个版本逻辑基本是一致的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">版本一： Go + C++版本。Go实现Http Server，Thrift调用C++逻辑代码。</span><br><span class="line">版本二： C++版本。C++实现Http Server（基于mongoose），逻辑部分和版本一一样，因为整合成了一个程序，所以直接调用逻辑部分的方法。</span><br><span class="line">版本三： Java版本。基于Spring Boot。</span><br></pre></td></tr></table></figure></p><p>在20的并发下，版本一最大QPS 3500左右，不过此时平均耗时已经增加到了30~40ms。版本二最大QPS 2000左右，平均耗时6ms。版本三最大QPS 5000~5500，平均耗时4ms。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>mongoose并不算很成熟，性能上也不怎么样。</li><li>如果真的需要使用，最好再进行一层封装。可以参考<a href="https://github.com/tashaxing/CppHttpDemo" target="_blank" rel="noopener">这位同学的实现</a>。</li><li>C++用于应用层不仅开发起来费时，得到的好处似乎也有限，可能是我太年轻？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有个奇葩的需求，需要用C++去实现一个Http Server。用Java或者其他语言去实现Http Server是一件很简单的事，但用C++去实现我就闻所未闻了（当然主要是我也没写过C++嘛）。于是去搜索了一把，不少人推荐&lt;a href=&quot;https://github.com/cesanta/mongoose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mongoose&lt;/a&gt;，在实际使用中遇到了不少的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Cpp" scheme="https://blog.darkness463.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Xposed检测</title>
    <link href="https://blog.darkness463.top/2018/06/20/Xposed-Check/"/>
    <id>https://blog.darkness463.top/2018/06/20/Xposed-Check/</id>
    <published>2018-06-20T07:57:49.000Z</published>
    <updated>2018-06-20T07:59:21.202Z</updated>
    
    <content type="html"><![CDATA[<p>这两天看到有部分人称微信大规模封号，主要被封的是Xposed和各类微信插件的使用者，部分人说自己只是安装了Xposed，但并未使用微信相关的任何插件也被封了。由此有人开始说微信侵犯用户隐私，随意扫描用户的手机等等。</p><p>本人一直是Xposed的使用者，主要是用来使用自己写的扒Android8.1上“吉字节”等单位改回“GB”的插件。另外也有使用修改微信UI以及防撤回的与微信相关的插件，但并未受到此次封号的影响。普通用户不太清楚开发方面的事，以为检测Xposed框架是件很复杂的事，今天就来聊聊Xposed的简单检测方法。</p><a id="more"></a><h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><p>Xposed重写了zygote，zygote启动时会加载Xposed相关组件，因此由zygote孵化出来的每个进程都会有Xposed的相关代码。根据这一原理，我们可以通过以下几种方式检测。</p><h2 id="Xposed-Installer"><a href="#Xposed-Installer" class="headerlink" title="Xposed Installer"></a>Xposed Installer</h2><p>Xposed利用Xposed Installer这一App安装Xposed和管理模块，其包名为<code>de.robv.android.xposed.installer</code>，检测这一包名是最简单直观的对Xposed检测的方法。</p><h2 id="堆栈信息"><a href="#堆栈信息" class="headerlink" title="堆栈信息"></a>堆栈信息</h2><p>抛出一个异常并捕获，将堆栈信息打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .....省略部分</span></span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:<span class="number">106</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">164</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6494</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">440</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">807</span>)</span><br><span class="line">at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:<span class="number">108</span>)</span><br></pre></td></tr></table></figure><p>可以看到每个App是先执行的XposedBridge.jar的main方法，之后再调用的Zygote的main方法。通过检测堆栈中是否包含<code>Xposed</code>等字样即可知道是否安装了Xposed。</p><h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><p>Xposed的组件需要被加载，必然在内存空间留下痕迹。通过遍历<code>/proc/&lt;pid&gt;/maps</code>（<code>/proc/self/maps</code>）的内容可以发现如下内容。因此也可以据此来判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>de6c41000-<span class="number">7</span>de6c42000 r--s <span class="number">00019000</span> b3:<span class="number">18</span> <span class="number">139265</span> /system/framework/XposedBridge.jar</span><br></pre></td></tr></table></figure><h2 id="更精准的检测"><a href="#更精准的检测" class="headerlink" title="更精准的检测"></a>更精准的检测</h2><p>以上方法只能检测用户是否安装使用了Xposed，这是一个风险点，但我们并不能因为用户使用了Xposed就将其封禁。通过Xposed的实现方式，我们可以采取更精准的方式去检测。</p><p>在<code>de.robv.android.xposed.XposedBridge</code>中有一个<code>disableHooks</code>字段用于标记对于当前应用是否要进行hook。通过获取这个字段的值就可以知道是否在我们App上启用hook了，甚至可以通过将其设置为true停掉Xposed。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Field disableHooksFiled = ClassLoader.getSystemClassLoader()</span><br><span class="line">        .loadClass(<span class="string">"de.robv.android.xposed.XposedBridge"</span>)</span><br><span class="line">        .getDeclaredField(<span class="string">"disableHooks"</span>);</span><br><span class="line">disableHooksFiled.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object enable = disableHooksFiled.get(<span class="keyword">null</span>);  <span class="comment">// 当前状态</span></span><br><span class="line">disableHooksFiled.set(<span class="keyword">null</span>, <span class="keyword">true</span>);            <span class="comment">// 设置为关闭</span></span><br></pre></td></tr></table></figure><p>另一个更为精准的方式见<a href="https://segmentfault.com/a/1190000009976827" target="_blank" rel="noopener">这篇文章</a>，Xposed将需要hook的字段、方法、构造函数等缓存在了几个HashMap中，通过遍历这几个看是否有与自己相关的内容就可知道自己是否有被hook了，具体的原理和方法可以看一下这篇文章。</p><h1 id="反检测与反反检测"><a href="#反检测与反反检测" class="headerlink" title="反检测与反反检测"></a>反检测与反反检测</h1><p>上面提到的那些检测方法实际上都可以被绕过的，hook掉调用的那些检测方法并返回虚假的信息就可以轻松绕过。例如上文提到检测maps文件，那么我们可以需要类似下面这样的伪代码遍历maps文件的每一行并判断是否包含Xposed的相关组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line.contains(<span class="string">"Xposed"</span>)</span><br></pre></td></tr></table></figure><p>那么可以hook<code>String.contains</code>方法，如果发现你想判断的内容包含<code>Xposed</code>等关键字就直接返回false即可。</p><p>面对这些反检测的手段，第一我们可以增加检测的维度，加大绕过检测的难度，从Java层和C层进行多方面的检测。第二我们可以设置一些蜜罐，例如面对上面这种反检测的手段，如果我们调用<code>&quot;Xposed&quot;.contains(&quot;Xposed&quot;)</code>的返回值是false，那必然说明其使用了这种反检测手段。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>攻防真的很无聊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天看到有部分人称微信大规模封号，主要被封的是Xposed和各类微信插件的使用者，部分人说自己只是安装了Xposed，但并未使用微信相关的任何插件也被封了。由此有人开始说微信侵犯用户隐私，随意扫描用户的手机等等。&lt;/p&gt;
&lt;p&gt;本人一直是Xposed的使用者，主要是用来使用自己写的扒Android8.1上“吉字节”等单位改回“GB”的插件。另外也有使用修改微信UI以及防撤回的与微信相关的插件，但并未受到此次封号的影响。普通用户不太清楚开发方面的事，以为检测Xposed框架是件很复杂的事，今天就来聊聊Xposed的简单检测方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
      <category term="Xposed" scheme="https://blog.darkness463.top/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>Android多开/分身检测</title>
    <link href="https://blog.darkness463.top/2018/05/04/Android-Virtual-Check/"/>
    <id>https://blog.darkness463.top/2018/05/04/Android-Virtual-Check/</id>
    <published>2018-05-04T08:59:34.000Z</published>
    <updated>2018-05-04T09:04:17.487Z</updated>
    
    <content type="html"><![CDATA[<p>多开/分身原本用于方便有多个微信/QQ解决同时登录的问题，但近来年被各种黑产所利用，多见于薅羊毛，部分多开App甚至提供了篡改功能。对于普通用户根本不会有多开的需求的App，一旦检测到当前运行在多开环境下，有理由限制该用户的后续行为。</p><p>在尝试了目前市面上多款多开App后，总结了几种检测方案。</p><a id="more"></a><h1 id="多开原理"><a href="#多开原理" class="headerlink" title="多开原理"></a>多开原理</h1><p>目前市面上的多开App的原理类似，都是以新进程运行被多开的App，并hook各类系统函数，使被多开的App认为自己是一个正常的App在运行。</p><p>从形式上来说多开App有2种形式，一种是从多开App中直接加载被多开的App，如平行空间、VirtualApp等，另一种是让用户新安装一个App，但这个App本质上就是一个壳，用来加载被多开的App，其原理和前一种是一样的，市面上多开分身这款App是用的这种形式，用户每分身一个App需新安装一个包名为dkmodel.xxx.xxx的App。</p><h1 id="检测方案"><a href="#检测方案" class="headerlink" title="检测方案"></a>检测方案</h1><h2 id="检测files目录路径"><a href="#检测files目录路径" class="headerlink" title="检测files目录路径"></a>检测files目录路径</h2><p>我们知道App的私有目录是<code>/data/data/包名/</code>或<code>/data/user/用户号/包名</code>，通过<code>Context.getFilesDir()</code>方法可以拿到私有目录下的<code>files</code>目录。在多开环境下，获取到目录会变为<code>/data/data/多开App的包名/xxxxxxxx</code>或<code>/data/user/用户号/多开App的包名/xxxxxxxx</code>。</p><p>举个例子，在我手机上，正常使用App上面的代码获取到的路径为<code>/data/user/0/top.darkness463.virtualcheck/files</code>。在多开分身的多开环境下，路径为<code>/data/user/0/dkmodel.zom.rxo/virtual/data/user/0/top.darkness463.virtualcheck/files</code>。</p><p>当然，多开软件是可以hook处理让你拿到正常的目录，但截至写这篇文章为止，市面上大部分多开App没有绕过这项检测，仅有360家的分身大师可以绕过。</p><h2 id="ps检测"><a href="#ps检测" class="headerlink" title="ps检测"></a>ps检测</h2><p>这种检测方法见<a href="https://www.jianshu.com/p/216d65d9971e" target="_blank" rel="noopener">这篇文章</a>。这里就不重复了，我简单说一下原理。</p><p>我们先通过执行<code>ps</code>命令并以自己的uid进行过滤，得到类似下面的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正常情况下</span><br><span class="line">u0_a148 8162 423 1806036 56368 SyS_epoll+ 0 S top.darkness463.virtualcheck</span><br><span class="line"></span><br><span class="line">// 多开环境下</span><br><span class="line">u0_a155 19752 422 4437612 62752 SyS_epoll+ 0 S top.darkness463.virtualcheck</span><br><span class="line">u0_a155 19758 422 564234 54356 SyS_epoll+ 0 S com.lbe.parallel</span><br><span class="line">u0_a155 19747 422 734562 24542 SyS_epoll+ 0 S com.lbe.parallel:mdserver</span><br></pre></td></tr></table></figure><p>可以看到在多开环境下，会获取到自己的包名和多开App的包名这2个包名，通过这些包名去<code>/data/data/</code>下找会找到2个目录，而正常情况下只能在<code>/data/data/</code>下找到自己的App的目录。</p><p>具体的实现原文已经贴了，这里也不重复了。目前未发现有多开App能绕过该项检测，但在Google Pixel Android 8.0下执行ps获取不到进程信息，在Android 8.1的类AOSP rom下都能正常获取，不知道那个手机什么情况。</p><h2 id="应用列表检测"><a href="#应用列表检测" class="headerlink" title="应用列表检测"></a>应用列表检测</h2><p>这里的应用列表检测不是指简单的遍历应用列表判断是不是安装了多开App，我们并不阻止用户安装多开App并多开其他App，我们只是不希望用户多开我们自己的App，因此不能检测到用户安装了多开App就把他干掉。</p><p>多开App都会对<code>context.getPackageName()</code>进行处理，让这个方法返回原始App的包名，因此在被多开的App看来，多开App的包名和原始的那个App的包名一样，因此在多开环境下遍历应用列表时会发现包名等于原始App的包名的应用会有两个。</p><p>代码如下。只对部分多开App有效，例如360的分身大师，不少多开App会绕过这项检测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPkg</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String packageName = context.getPackageName();</span><br><span class="line">        PackageManager pm = context.getPackageManager();</span><br><span class="line">        List&lt;PackageInfo&gt; pkgs = pm.getInstalledPackages(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (PackageInfo info : pkgs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (packageName.equals(info.packageName)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maps检测"><a href="#maps检测" class="headerlink" title="maps检测"></a>maps检测</h2><p>读取<code>/proc/self/maps</code>，多开App会加载一些自己的so到内存空间，举个例子，360的分身大师加载了其目录下的某个so，<code>/data/app/com.qihoo.magic-gdEsg8KRAuJy0MuY18BlqQ==/lib/arm/libbreakpad-jni-1.5.so</code>，通过对各种多开App的包名的匹配，如果maps中有多开App的包名的东西，那么当前就是运行在多开环境下。</p><p>目前没有发现多开App绕过该项检测，但缺点是需要收集所有多开App的包名，一旦多开App改个包名就失效了。</p><p>伪代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Set&lt;String&gt; virtualPkgs;  <span class="comment">// 多开App包名列表</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BufferedReader bufr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"/proc/self/maps"</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String pkg : virtualPkgs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line.contains(pkg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些方法有的已经被部分多开App绕过了，有的暂时还未绕过，建议所有的检测都加上，而且可以Java层和C层都进行检测。当然，与黑产斗争的道路我们永远处于劣势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多开/分身原本用于方便有多个微信/QQ解决同时登录的问题，但近来年被各种黑产所利用，多见于薅羊毛，部分多开App甚至提供了篡改功能。对于普通用户根本不会有多开的需求的App，一旦检测到当前运行在多开环境下，有理由限制该用户的后续行为。&lt;/p&gt;
&lt;p&gt;在尝试了目前市面上多款多开App后，总结了几种检测方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【All in One】Once</title>
    <link href="https://blog.darkness463.top/2018/04/10/All-in-One-Once/"/>
    <id>https://blog.darkness463.top/2018/04/10/All-in-One-Once/</id>
    <published>2018-04-10T13:33:13.000Z</published>
    <updated>2018-04-10T13:34:38.370Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jonfinerty/Once" target="_blank" rel="noopener">Once</a>是一个开源的用于管理一些只需要进行一次（或几次）的操作的库。比如说只显示一次引导页，每个版本只显示一次更新说明等等。</p><a id="more"></a><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.jonathanfinerty.once:once:1.2.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Once.initialise(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>检测某项操作是否已进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String showWhatsNew = <span class="string">"showWhatsNewTag"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否需要进行操作</span></span><br><span class="line"><span class="keyword">if</span> (!Once.beenDone(Once.THIS_APP_VERSION, showWhatsNew)) &#123;</span><br><span class="line">    startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, WhatsNewActivity.class));</span><br><span class="line">    <span class="comment">// 完成后进行标记</span></span><br><span class="line">    Once.markDone(showWhatsNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once支持3种尺度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">THIS_APP_INSTALL: 安装到卸载前，例如引导页只出现一次，升级也不重复出现。</span><br><span class="line">THIS_APP_VERSION: 当前版本，例如更新说明，一个版本出现一次。</span><br><span class="line">THIS_APP_SESSION: 本次使用。</span><br></pre></td></tr></table></figure><p>此外，也支持如果时间，在设定的时间内进行一次操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Once.beenDone(TimeUnit.HOURS, <span class="number">1</span>, phonedHome) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Once还支持将某件事标记为”to do”，之后检查是否需要做某项操作。Once给我们举了个例子，有时你想在用户看到基础功能后，在MainActivity中显示一些高级功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// in the basic functionality activity</span></span><br><span class="line">Once.toDo(Once.THIS_APP_INSTALL, <span class="string">"show feature onboarding"</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// back in the home activity</span></span><br><span class="line"><span class="keyword">if</span> (Once.needToDo(showAppTour)) &#123;</span><br><span class="line">    <span class="comment">// do some operations</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after task has been done, mark it as done as normal</span></span><br><span class="line">    Once.markDone(showAppTour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了进行一次，Once也支持第N次后进行某些操作。例如，在用户使用3次App后弹出让用户评分的dialog。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once again in the basic functionality activity</span></span><br><span class="line">Once.markDone(<span class="string">"action"</span>);</span><br><span class="line"><span class="keyword">if</span> (Once.beenDone(<span class="string">"action"</span>, Amount.exactly(<span class="number">3</span>))) &#123;</span><br><span class="line">    showRateTheAppDialog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持下面这三种</span></span><br><span class="line">Amount.exactly(<span class="keyword">int</span> x)   <span class="comment">// 第x次时</span></span><br><span class="line">Amount.lessThan(<span class="keyword">int</span> x)  <span class="comment">// 小于x次时</span></span><br><span class="line">Amount.moreThan(<span class="keyword">int</span> x)  <span class="comment">// 大于x次时</span></span><br></pre></td></tr></table></figure><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>Once的功能很简单，如果不使用Once而是自己实现的话，我们必然会用SharedPreferences去记录是否进行过某些操作，Once的实现也是类似的。</p><h2 id="PersistedMap和PersistedSet"><a href="#PersistedMap和PersistedSet" class="headerlink" title="PersistedMap和PersistedSet"></a>PersistedMap和PersistedSet</h2><p>这两个类是Once中保存和处理SharedPreferences。PersistedMap对应名为PersistedMapTagLastSeenMap的sp，用于保存那些被markDone的tag的时间戳，sp中保存的key为tag，value为时间戳拼成的字符串，以逗号分隔各时间戳，在PersistedMap中保存在<code>Map&lt;String, List&lt;Long&gt;&gt; map</code>对象中，map的key为tag，List即为由时间戳字符串还原成的list。PersistedSet对应名为PersistedSetToDoSet的sp，用于保存被标记为todo的tag，Android3.0以上的版本直接已Set的形式保存在sp中，3.0以下以字符串形式保存，用逗号分隔。</p><p>PersistedMap和PersistedSet的实现类似，初始化时通过AsyncTask异步去加载各自的SharedPreferences，提供put、remove等方法，调用这些方法会更新内存中的Map/Set，并更新sp。</p><h2 id="AsyncSharedPreferenceLoader"><a href="#AsyncSharedPreferenceLoader" class="headerlink" title="AsyncSharedPreferenceLoader"></a>AsyncSharedPreferenceLoader</h2><p>供PersistedMap和PersistedSet加载SharedPreferences使用。内部实现了一个AsyncTask用于异步加载SharedPreferences，并提供get()方法用于获取加载后的SharedPreferences。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncTask&lt;String, Void, SharedPreferences&gt; asyncTask = <span class="keyword">new</span> AsyncTask&lt;String, Void, SharedPreferences&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SharedPreferences <span class="title">doInBackground</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getSharedPreferences(names[<span class="number">0</span>], Context.MODE_PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SharedPreferences <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> asyncTask.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException ignored) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>Once的主类，提供了Once能实现的所有功能。这里只介绍一些主要方法的实现。</p><h3 id="initialise"><a href="#initialise" class="headerlink" title="initialise"></a>initialise</h3><p>初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialise</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化PersistedMap和PersistedSet</span></span><br><span class="line">    tagLastSeenMap = <span class="keyword">new</span> PersistedMap(context, <span class="string">"TagLastSeenMap"</span>);</span><br><span class="line">    toDoSet = <span class="keyword">new</span> PersistedSet(context, <span class="string">"ToDoSet"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sessionList用于保存处理THIS_APP_SESSION级别的tag。</span></span><br><span class="line">    <span class="keyword">if</span> (sessionList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sessionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取lastAppUpdatedTime，用于处理THIS_APP_VERSION级别。</span></span><br><span class="line">    PackageManager packageManager = context.getPackageManager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageInfo packageInfo = packageManager.getPackageInfo(context.getPackageName(), <span class="number">0</span>);</span><br><span class="line">        lastAppUpdatedTime = packageInfo.lastUpdateTime;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException ignored) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="markDone"><a href="#markDone" class="headerlink" title="markDone"></a>markDone</h3><p>用于记录某个tag对应的操作的完成。会将当前时间戳增加进PersistedMap中，向sessionList中添加该tag，并从PersistedSet中将该tag移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markDone</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">    tagLastSeenMap.put(tag, <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    sessionList.add(tag);</span><br><span class="line">    toDoSet.remove(tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beenDone"><a href="#beenDone" class="headerlink" title="beenDone"></a>beenDone</h3><p>用于判断某个tag是否已完成。有一系列重载的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THIS_APP_INSTALL级别，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(String tag);</span><br><span class="line"><span class="comment">// THIS_APP_INSTALL级别，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(String tag, CountChecker numberOfTimes);</span><br><span class="line"><span class="comment">// 自定义scope，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(<span class="meta">@Scope</span> <span class="keyword">int</span> scope, String tag);</span><br><span class="line"><span class="comment">// 自定义scope，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(<span class="meta">@Scope</span> <span class="keyword">int</span> scope, String tag, CountChecker numberOfTimes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// amount * timeUnit之前至今，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(TimeUnit timeUnit, <span class="keyword">long</span> amount, String tag);</span><br><span class="line"><span class="comment">// amount * timeUnit之前至今，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(TimeUnit timeUnit, <span class="keyword">long</span> amount, String tag, CountChecker numberOfTimes);</span><br><span class="line"><span class="comment">// timeSpanInMillis之前至今，该tag是否满足moreThan(0)。</span></span><br><span class="line">beenDone(<span class="keyword">long</span> timeSpanInMillis, String tag);</span><br><span class="line"><span class="comment">// timeSpanInMillis之前至今，该tag是否满足传入的numberOfTimes条件。</span></span><br><span class="line">beenDone(<span class="keyword">long</span> timeSpanInMillis, String tag, CountChecker numberOfTimes);</span><br></pre></td></tr></table></figure><p>前4个方法以scope为维度，最终都会调用到<code>beenDone(@Scope int scope, String tag, CountChecker numberOfTimes)</code>，后4个方法以时间为维度，最终都会调用<code>beenDone(long timeSpanInMillis, String tag, CountChecker numberOfTimes)</code>，我们来看一下这2个方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">beenDone</span><span class="params">(@Scope <span class="keyword">int</span> scope, String tag, CountChecker numberOfTimes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该tag所有的记录。</span></span><br><span class="line">    List&lt;Long&gt; tagSeenDates = tagLastSeenMap.get(tag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagSeenDates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">    <span class="keyword">if</span> (scope == THIS_APP_INSTALL) &#123;</span><br><span class="line">        <span class="comment">// THIS_APP_INSTALL级别，直接和记录的size比较。</span></span><br><span class="line">        <span class="keyword">return</span> numberOfTimes.check(tagSeenDates.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == THIS_APP_SESSION) &#123;</span><br><span class="line">        <span class="comment">// THIS_APP_SESSION级别，和sessionList中该tag的个数比较。</span></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String tagFromList : sessionList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagFromList.equals(tag)) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numberOfTimes.check(counter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// THIS_APP_VERSION级别，记录中大于lastAppUpdatedTime的才计算进去。</span></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long seenDate : tagSeenDates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seenDate &gt; lastAppUpdatedTime) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numberOfTimes.check(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">beenDone</span><span class="params">(<span class="keyword">long</span> timeSpanInMillis, String tag, CountChecker numberOfTimes)</span> </span>&#123;</span><br><span class="line">    List&lt;Long&gt; tagSeenDates = tagLastSeenMap.get(tag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tagSeenDates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Long seenDate : tagSeenDates) &#123;</span><br><span class="line">        <span class="comment">// 计算出最小的有效时间</span></span><br><span class="line">        <span class="keyword">long</span> sinceSinceCheckTime = <span class="keyword">new</span> Date().getTime() - timeSpanInMillis;</span><br><span class="line">        <span class="comment">// 比较记录的时间和有效时间，比有效时间大的才计入。</span></span><br><span class="line">        <span class="keyword">if</span> (seenDate &gt; sinceSinceCheckTime) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numberOfTimes.check(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toDo-needToDo"><a href="#toDo-needToDo" class="headerlink" title="toDo/needToDo"></a>toDo/needToDo</h3><p>toDo用于标记某个tag “need to do”。有<code>toDo(@Scope int scope, String tag)</code>和<code>toDo(String tag)</code>2个方法。需要注意的是，使用<code>toDo(@Scope int scope, String tag)</code>时，如果该tag之前被markDone过，则仅当传入的scope为THIS_APP_VERSION且该tag上次被markDone的时间在lastAppUpdatedTime之前才会将该tag添加到PersistedSet中。而<code>toDo(String tag)</code>则无论该tag之前有没有被markDone，都会添加到PersistedSet中。<br>needToDo即用于检查PersistedSet中是否存在对应的tag。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Once可以帮我们方便地管理一些操作在什么时候进行。</li><li>利用SharedPreferences保存记录。</li><li>支持<code>THIS_APP_INSTALL</code>、<code>THIS_APP_VERSION</code>、<code>THIS_APP_SESSION</code>三种级别。利用每次markDone的时间戳实现对三种级别的支持。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/jonfinerty/Once&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Once&lt;/a&gt;是一个开源的用于管理一些只需要进行一次（或几次）的操作的库。比如说只显示一次引导页，每个版本只显示一次更新说明等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
      <category term="All in One" scheme="https://blog.darkness463.top/tags/All-in-One/"/>
    
      <category term="Once" scheme="https://blog.darkness463.top/tags/Once/"/>
    
  </entry>
  
  <entry>
    <title>Android-ConditionVariable</title>
    <link href="https://blog.darkness463.top/2018/03/28/Android-ConditionVariable/"/>
    <id>https://blog.darkness463.top/2018/03/28/Android-ConditionVariable/</id>
    <published>2018-03-28T02:08:39.000Z</published>
    <updated>2018-03-28T02:09:48.674Z</updated>
    
    <content type="html"><![CDATA[<p>ConditionVariable是Android提供的用于wait和notify的类，与java的wait()和notify()不同的地方在于ConditionVarible可以根据状态决定是否wait。</p><a id="more"></a><h2 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h2><p>ConditionVariable有四个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 释放所以block的线程，且将状态设置为open，如果之后不调用close()，则调用block()不会阻塞。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将状态设置为close。之后调用block()将会阻塞。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果状态不为open，则阻塞当前线程直到调用open()，否则直接返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">block</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果状态不为open，则阻塞当前线程直到调用open()或达到timeout时间，否则直接返回。</span></span><br><span class="line"><span class="comment">* 如果是因为open而返回，则返回true，如果是因为超市而返回，则返回false。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">block</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>ConditionVariable的实现非常简单，根据<code>mCondition</code>变量的值决定当前是open还是close状态，<code>mCondition</code>等于true时为open，false时为close。调用block()时，仅在<code>mCondition</code>等于false时才会调用wait()。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ConditionVariable简化了wait()和notify()的编写，如果需要根据情况决定是否wait，可以考虑使用ConditionVariable。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConditionVariable是Android提供的用于wait和notify的类，与java的wait()和notify()不同的地方在于ConditionVarible可以根据状态决定是否wait。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>废话几句</title>
    <link href="https://blog.darkness463.top/2018/03/27/say-something/"/>
    <id>https://blog.darkness463.top/2018/03/27/say-something/</id>
    <published>2018-03-27T15:21:17.000Z</published>
    <updated>2018-03-27T15:27:42.705Z</updated>
    
    <content type="html"><![CDATA[<p><em>全是废话</em></p><a id="more"></a><p>当初在Github上搭了这个站之后就几乎没发过什么东西，后来买了一个域名也没有鸟过了。</p><p>这两天看到了由<a href="https://github.com/yscoder" target="_blank" rel="noopener">yscoder</a>开源的hexo主题<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">hexo-theme-indigo</a>，挺好看的，于是把之前的推倒重来了。</p><p>之前的几篇东西受限于当时知识的有限，有一些不太对的地方，但是懒得改了，所以也就不放上来了，只把几篇总结笔记类的改了格式传上来了。</p><p>之后多写点东西吧(大概吧)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;全是废话&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【总结】Android辅助功能(一)-AccessibilityEvent的分发</title>
    <link href="https://blog.darkness463.top/2017/04/17/accessibility-event/"/>
    <id>https://blog.darkness463.top/2017/04/17/accessibility-event/</id>
    <published>2017-04-17T05:41:10.000Z</published>
    <updated>2018-03-27T15:28:41.853Z</updated>
    
    <content type="html"><![CDATA[<p>目前关于辅助功能的使用的文章很多，但鲜有分析其具体实现的，本文基于Andoird 7.1.0_r7源码分析一下辅助事件是怎么分发的，只涉及事件的分发和辅助App的接收，之后有机会再讲一讲获取AccessibilityNodeInfo、进行操作等等的源码流程。<br><a id="more"></a><br>文中“目标App”指的是发出辅助事件的App，“辅助App”指的是拥有辅助功能的App。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="【目标App】-View-sendAccessibilityEvent-int-eventType"><a href="#【目标App】-View-sendAccessibilityEvent-int-eventType" class="headerlink" title="【目标App】 View.sendAccessibilityEvent(int eventType)"></a>【目标App】 View.sendAccessibilityEvent(int eventType)</h2><p>我们看View的源码可以看到在很多地方调用了sendAccessibilityEvent(int eventType)的方法，例如：</p><pre><code>在View获取到焦点时，调用了sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED)；当View被点击时，调用了sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED)</code></pre><p>使用过辅助功能的同学对这些Event应该很熟悉，这些就是我们在写辅助App时定义的想要接收的辅助事件的类型，Android为我们定义了一系列辅助事件，这里举几个比较常用的事件：</p><pre><code>TYPE_VIEW_CLICKED    // 当View被点击时发送此事件。TYPE_VIEW_LONG_CLICKED    // 当View被长按时发送此事件。TYPE_VIEW_FOCUSED    // 当View获取到焦点时发送此事件。TYPE_WINDOW_STATE_CHANGED    // 当Window发生变化时发送此事件。TYPE_VIEW_SCROLLED    // 当View滑动时发送此事件。</code></pre><p>所以说，sendAccessibilityEvent(int eventType)就是我们的起点，我们来看一看这个方法。View实现了AccessibilityEventSource接口，这个方法就来自于AccessibilityEventSource接口。</p><pre><code>public void sendAccessibilityEvent(int eventType) {    if (mAccessibilityDelegate != null) {        // AccessibilityDelegate是用来增强辅助功能的，一般情况下不用考虑。        mAccessibilityDelegate.sendAccessibilityEvent(this, eventType);    } else {        sendAccessibilityEventInternal(eventType);    }}</code></pre><h2 id="【目标App】-View-sendAccessibilityEventInternal-int-eventType-gt-View-sendAccessibilityEventUnchecked-AccessibilityEvent-event"><a href="#【目标App】-View-sendAccessibilityEventInternal-int-eventType-gt-View-sendAccessibilityEventUnchecked-AccessibilityEvent-event" class="headerlink" title="【目标App】 View.sendAccessibilityEventInternal(int eventType) -&gt; View.sendAccessibilityEventUnchecked(AccessibilityEvent event)"></a>【目标App】 View.sendAccessibilityEventInternal(int eventType) -&gt; View.sendAccessibilityEventUnchecked(AccessibilityEvent event)</h2><p>这2个方法都比较短，就放在一起说了。sendAccessibilityEventInternal(int eventType)会检查当前辅助服务是否开启，至少有一个辅助App被开启了才会返回true。如果当前开启了，会把eventType转成AccessibilityEvent，这就是我们在AccessibilityService中收到的AccessibilityEvent，之后调用了sendAccessibilityEventUnchecked(AccessibilityEvent event)，进而调用了sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)。</p><pre><code>public void sendAccessibilityEventInternal(int eventType) {    if (AccessibilityManager.getInstance(mContext).isEnabled()) {        sendAccessibilityEventUnchecked(AccessibilityEvent.obtain(eventType));    }}public void sendAccessibilityEventUnchecked(AccessibilityEvent event) {    if (mAccessibilityDelegate != null) {        // AccessibilityDelegate是用来增强辅助功能的，一般情况下不用考虑。        mAccessibilityDelegate.sendAccessibilityEventUnchecked(this, event);    } else {        sendAccessibilityEventUncheckedInternal(event);    }}</code></pre><h2 id="【目标App】-View-sendAccessibilityEventUncheckedInternal-AccessibilityEvent-event"><a href="#【目标App】-View-sendAccessibilityEventUncheckedInternal-AccessibilityEvent-event" class="headerlink" title="【目标App】 View.sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)"></a>【目标App】 View.sendAccessibilityEventUncheckedInternal(AccessibilityEvent event)</h2><p>此时会先判断当前View及所有的Parent是否可见，如果不可见则不会分发当前的AccessibilityEvent。onInitializeAccessibilityEvent(event)做了一些初始化工作，例如给AccessibilityEvent设置source、className、packageName等等信息。</p><p>系统定义了一个叫POPULATING_ACCESSIBILITY_EVENT_TYPES的常量，包括了AccessibilityEvent.TYPE_VIEW_CLICKED等等一系列Event，当发送的EventType是这些中的一个时，目标App可以通过重写dispatchPopulateAccessibilityEvent(AccessibilityEvent event)或onPopulateAccessibilityEvent(AccessibilityEvent event)方法对将要发送的AccessibilityEvent进行修改。</p><p>之后会调用getParent().requestSendAccessibilityEvent(this, event)发给Parent View去处理。</p><pre><code>public void sendAccessibilityEventUncheckedInternal(AccessibilityEvent event) {    // 判断View是否可见    if (!isShown()) {        return;    }    // 设置AccessibilityEvent的一些信息    onInitializeAccessibilityEvent(event);    if ((event.getEventType() &amp; POPULATING_ACCESSIBILITY_EVENT_TYPES) != 0) {        // 目标App可通过此方法修改AccessibilityEvent        dispatchPopulateAccessibilityEvent(event);    }    // In the beginning we called #isShown(), so we know that getParent() is not null.    getParent().requestSendAccessibilityEvent(this, event);}private static final int POPULATING_ACCESSIBILITY_EVENT_TYPES =        AccessibilityEvent.TYPE_VIEW_CLICKED        | AccessibilityEvent.TYPE_VIEW_LONG_CLICKED        | AccessibilityEvent.TYPE_VIEW_SELECTED        | AccessibilityEvent.TYPE_VIEW_FOCUSED        | AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED        | AccessibilityEvent.TYPE_VIEW_HOVER_ENTER        | AccessibilityEvent.TYPE_VIEW_HOVER_EXIT        | AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED        | AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED        | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED        | AccessibilityEvent.TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY;</code></pre><h2 id="【目标App】ViewGroup-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event"><a href="#【目标App】ViewGroup-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event" class="headerlink" title="【目标App】ViewGroup.requestSendAccessibilityEvent(View child, AccessibilityEvent event)"></a>【目标App】ViewGroup.requestSendAccessibilityEvent(View child, AccessibilityEvent event)</h2><p>对于一个View来说，它的Parent View就是ViewGroup，这里会递归调用Parent View的requestSendAccessibilityEvent方法，值得注意的是onRequestSendAccessibilityEvent(View child, AccessibilityEvent event)方法，官方的注释说是“当子View请求发送一个AccessibilityEvent时调用，给父View一个增加事件的机会。” 但我觉得更大的用处是可以通过重写这个方法阻止事件的发送。</p><p>我们知道正常情况下，最终我们会调用DecorView的requestSendAccessibilityEvent(View child, AccessibilityEvent event)，而DecorView的Parent是ViewRootImpl，所以说最终会调用ViewRootImpl的requestSendAccessibilityEvent(View child, AccessibilityEvent event)方法。</p><pre><code>@Overridepublic boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {    ViewParent parent = mParent;    if (parent == null) {        return false;    }    // 自定义View可以重写这个方法阻止事件的发送。    final boolean propagate = onRequestSendAccessibilityEvent(child, event);    if (!propagate) {        return false;    }    return parent.requestSendAccessibilityEvent(this, event);}</code></pre><h2 id="【目标App】ViewRootImpl-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event"><a href="#【目标App】ViewRootImpl-requestSendAccessibilityEvent-View-child-AccessibilityEvent-event" class="headerlink" title="【目标App】ViewRootImpl.requestSendAccessibilityEvent(View child, AccessibilityEvent event)"></a>【目标App】ViewRootImpl.requestSendAccessibilityEvent(View child, AccessibilityEvent event)</h2><p>该方法对几个特殊的EventType进行了处理，在此我们先不关注，之后调用AccessibilityManager的sendAccessibilityEvent(AccessibilityEvent event)方法。</p><pre><code>public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {    if (mView == null || mStopped || mPausedForTransition) {        return false;    }    final int eventType = event.getEventType();    switch (eventType) {        // 对某些eventType进行了特殊处理，在此省略    }    mAccessibilityManager.sendAccessibilityEvent(event);    return true;}</code></pre><h2 id="【目标App】AccessibilityManager-sendAccessibilityEvent-AccessibilityEvent-event"><a href="#【目标App】AccessibilityManager-sendAccessibilityEvent-AccessibilityEvent-event" class="headerlink" title="【目标App】AccessibilityManager.sendAccessibilityEvent(AccessibilityEvent event)"></a>【目标App】AccessibilityManager.sendAccessibilityEvent(AccessibilityEvent event)</h2><p>这里再次检查了辅助功能当前是否开启，之后就通过Binder进入AccessibilityManagerService【下文简称AMS，额，不要以为是ActivityManagerService】的世界了。</p><pre><code>public void sendAccessibilityEvent(AccessibilityEvent event) {    final IAccessibilityManager service;    final int userId;    synchronized (mLock) {        service = getServiceLocked();        if (service == null) {            return;        }        if (!mIsEnabled) {            Looper myLooper = Looper.myLooper();            if (myLooper == Looper.getMainLooper()) {                throw new IllegalStateException(                        &quot;Accessibility off. Did you forget to check that?&quot;);            } else {                Log.e(LOG_TAG, &quot;AccessibilityEvent sent with accessibility disabled&quot;);                return;            }        }        userId = mUserId;    }    boolean doRecycle = false;    try {        event.setEventTime(SystemClock.uptimeMillis());        long identityToken = Binder.clearCallingIdentity();        // 向AccessibilityManagerService发送AccessibilityEvent        doRecycle = service.sendAccessibilityEvent(event, userId);        Binder.restoreCallingIdentity(identityToken);        if (DEBUG) {            Log.i(LOG_TAG, event + &quot; sent&quot;);        }    } catch (RemoteException re) {        Log.e(LOG_TAG, &quot;Error during sending &quot; + event + &quot; &quot;, re);    } finally {        if (doRecycle) {            event.recycle();        }    }</code></pre><h2 id="【AMS】-AccessibilityManagerService-sendAccessibilityEvent-AccessibilityEvent-event-int-userId"><a href="#【AMS】-AccessibilityManagerService-sendAccessibilityEvent-AccessibilityEvent-event-int-userId" class="headerlink" title="【AMS】 AccessibilityManagerService.sendAccessibilityEvent(AccessibilityEvent event, int userId)"></a>【AMS】 AccessibilityManagerService.sendAccessibilityEvent(AccessibilityEvent event, int userId)</h2><p>在进行了一些检查和准备工作后，最后调用notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)准备开始分发。</p><pre><code>@Overridepublic boolean sendAccessibilityEvent(AccessibilityEvent event, int userId) {    synchronized (mLock) {        final int resolvedUserId = mSecurityPolicy                .resolveCallingUserIdEnforcingPermissionsLocked(userId);        if (resolvedUserId != mCurrentUserId) {            return true; // yes, recycle the event        }        if (mSecurityPolicy.canDispatchAccessibilityEventLocked(event)) {            mSecurityPolicy.updateActiveAndAccessibilityFocusedWindowLocked(event.getWindowId(),                    event.getSourceNodeId(), event.getEventType(), event.getAction());            mSecurityPolicy.updateEventSourceLocked(event);            // 开始分发AccessibilityEvent            notifyAccessibilityServicesDelayedLocked(event, false);            notifyAccessibilityServicesDelayedLocked(event, true);        }        if (mHasInputFilter &amp;&amp; mInputFilter != null) {            mMainHandler.obtainMessage(MainHandler.MSG_SEND_ACCESSIBILITY_EVENT_TO_INPUT_FILTER,                    AccessibilityEvent.obtain(event)).sendToTarget();        }        event.recycle();    }    return (OWN_PROCESS_ID != Binder.getCallingPid());}</code></pre><h2 id="【AMS】-AccessibilityManagerService-notifyAccessibilityServicesDelayedLocked-AccessibilityEvent-event-boolean-isDefault"><a href="#【AMS】-AccessibilityManagerService-notifyAccessibilityServicesDelayedLocked-AccessibilityEvent-event-boolean-isDefault" class="headerlink" title="【AMS】 AccessibilityManagerService.notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)"></a>【AMS】 AccessibilityManagerService.notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault)</h2><p>UserState是AccessibilityManagerService一个内部类，在这个类里保存了一个用户当前安装了的、开启了的、已经建立连接的AccessibilityService列表等等信息。在初始化、安装/卸载应用、切换用户、开关辅助功能等等操作时，系统会对UserState的信息进行更新。mBoundServices中保存的就是当前已经启动了的Service列表，Service类也是AccessibilityManagerService的一个内部类，里面储存了从辅助App读取到的配置信息，即我们在辅助App的xml里配置的内容，并且Service类还会负责与各个AccessibilityService建立连接、进行通讯，管理着AccessibilityService的生命周期。此时会调用每个Service的notifyAccessibilityEvent(AccessibilityEvent event)进行事件的分发。</p><p>其中canDispatchEventToServiceLocked(Service service, AccessibilityEvent event)方法是用于判断该Service是否可以接收当前的AccessibilityEvent，即根据辅助App配置的需要接收的EventType和packageName等信息进行判断。</p><pre><code>private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event, boolean isDefault) {    try {        UserState state = getCurrentUserStateLocked();        for (int i = 0, count = state.mBoundServices.size(); i &lt; count; i++) {            Service service = state.mBoundServices.get(i);            if (service.mIsDefault == isDefault) {                // 辅助App接收该packageName和该EventType时才会分发                if (canDispatchEventToServiceLocked(service, event)) {                    service.notifyAccessibilityEvent(event);                }            }        }    } catch (IndexOutOfBoundsException oobe) {        // An out of bounds exception can happen if services are going away        // as the for loop is running. If that happens, just bail because        // there are no more services to notify.    }}</code></pre><h2 id="【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEvent-AccessibilityEvent-event"><a href="#【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEvent-AccessibilityEvent-event" class="headerlink" title="【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEvent(AccessibilityEvent event)"></a>【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEvent(AccessibilityEvent event)</h2><p>利用Service里定义的Handler把事件发出去，在handleMessage中进而调用了notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)方法。</p><pre><code>public void notifyAccessibilityEvent(AccessibilityEvent event) {        synchronized (mLock) {            final int eventType = event.getEventType();            // 复制当前的AccessibilityEvent            AccessibilityEvent newEvent = AccessibilityEvent.obtain(event);            Message message;            if ((mNotificationTimeout &gt; 0)                    &amp;&amp; (eventType != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED)) {                // Allow at most one pending event                final AccessibilityEvent oldEvent = mPendingEvents.get(eventType);                mPendingEvents.put(eventType, newEvent);                if (oldEvent != null) {                    mEventDispatchHandler.removeMessages(eventType);                    oldEvent.recycle();                }                message = mEventDispatchHandler.obtainMessage(eventType);            } else {                // Send all messages, bypassing mPendingEvents                message = mEventDispatchHandler.obtainMessage(eventType, newEvent);            }            mEventDispatchHandler.sendMessageDelayed(message, mNotificationTimeout);        }    }public Handler mEventDispatchHandler = new Handler(mMainHandler.getLooper()) {        @Override        public void handleMessage(Message message) {            final int eventType =  message.what;            AccessibilityEvent event = (AccessibilityEvent) message.obj;            notifyAccessibilityEventInternal(eventType, event);        }    };</code></pre><h2 id="【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEventInternal-int-eventType-AccessibilityEvent-event"><a href="#【AMS】-AccessibilityManagerService-Service-notifyAccessibilityEventInternal-int-eventType-AccessibilityEvent-event" class="headerlink" title="【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)"></a>【AMS】 AccessibilityManagerService.Service.notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event)</h2><p>该方法中的IAccessibilityServiceClient是AccessibilityService中的内部类IAccessibilityServiceClientWrapper，通过Binder调用了其onAccessibilityEvent(AccessibilityEvent event)方法。之后我们便转入了辅助App也就是接收辅助事件的App中。</p><pre><code>private void notifyAccessibilityEventInternal(int eventType, AccessibilityEvent event) {        IAccessibilityServiceClient listener;        synchronized (mLock) {            listener = mServiceInterface;            // If the service died/was disabled while the message for dispatching            // the accessibility event was propagating the listener may be null.            if (listener == null) {                return;            }            if (event == null) {                event = mPendingEvents.get(eventType);                if (event == null) {                    return;                }                mPendingEvents.remove(eventType);            }            if (mSecurityPolicy.canRetrieveWindowContentLocked(this)) {                event.setConnectionId(mId);            } else {                event.setSource(null);            }            event.setSealed(true);        }        try {            // 分发给辅助App            listener.onAccessibilityEvent(event);            if (DEBUG) {                Slog.i(LOG_TAG, &quot;Event &quot; + event + &quot; sent to &quot; + listener);            }        } catch (RemoteException re) {            Slog.e(LOG_TAG, &quot;Error during sending &quot; + event + &quot; to &quot; + listener, re);        } finally {            event.recycle();        }    }</code></pre><h2 id="【辅助App】-AccessibilityService-IAccessibilityServiceClientWrapper-onAccessibilityEvent-AccessibilityEvent-event"><a href="#【辅助App】-AccessibilityService-IAccessibilityServiceClientWrapper-onAccessibilityEvent-AccessibilityEvent-event" class="headerlink" title="【辅助App】 AccessibilityService.IAccessibilityServiceClientWrapper.onAccessibilityEvent(AccessibilityEvent event)"></a>【辅助App】 AccessibilityService.IAccessibilityServiceClientWrapper.onAccessibilityEvent(AccessibilityEvent event)</h2><p>此时通过mCaller发送了message code为DO_ON_ACCESSIBILITY_EVENT的Message，mCaller是IAccessibilityServiceClientWrapper中持有的一个HandlerCaller，在IAccessibilityServiceClientWrapper的构造方法中通过mCaller = new HandlerCaller(context, looper, this, true /<em>asyncHandler</em>/)创建，其中第三个参数即HandlerCaller的Callback，因此最终会回调IAccessibilityServiceClientWrapper的executeMessage方法。</p><p>在此我们只看message code为DO_ON_ACCESSIBILITY_EVENT的实现，可以看到最后调用的是mCallback.onAccessibilityEvent(event)，这个mCallback是什么呢？在AccessibilityService里定义了一个接口Callbacks，IAccessibilityServiceClientWrapper中持有的这个Callbacks是由其构造方法传入的参数。而IAccessibilityServiceClientWrapper是在AccessibilityService的onBind(Intent intent)方法中生成了，其中Callbacks的onAccessibilityEvent(AccessibilityEvent event)方法实现非常简单，直接调用了AccessibilityService.this.onAccessibilityEvent(event)，这个也就是我们在辅助App中重写的onAccessibilityEvent(AccessibilityEvent event)方法了。</p><pre><code>public void onAccessibilityEvent(AccessibilityEvent event) {    Message message = mCaller.obtainMessageO(DO_ON_ACCESSIBILITY_EVENT, event);    mCaller.sendMessage(message);}public void executeMessage(Message message) {        switch (message.what) {            case DO_ON_ACCESSIBILITY_EVENT: {                AccessibilityEvent event = (AccessibilityEvent) message.obj;                if (event != null) {                    // 如果是设计UI方面的eventType会对一些缓存进行更新                    AccessibilityInteractionClient.getInstance().onAccessibilityEvent(event);                    mCallback.onAccessibilityEvent(event);                    // Make sure the event is recycled.                    try {                        event.recycle();                    } catch (IllegalStateException ise) {                        /* ignore - best effort */                    }                }            } return;            ...// 其他实现省略        }    }@Overridepublic void onAccessibilityEvent(AccessibilityEvent event) {    AccessibilityService.this.onAccessibilityEvent(event);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，AccessibilityEvent便由目标App经由AccessibilityManagerService发送到了辅助App上，如果用图展示的话大致如下（图中省去了部分Handler的流程）：</p><p><a href="AccessibilityEvent.png">点击查看大图</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/04/17/accessibility-event/AccessibilityEvent.png" alt="Accessibility" title="">                </div>                <div class="image-caption">Accessibility</div>            </figure><h1 id="补遗"><a href="#补遗" class="headerlink" title="补遗"></a>补遗</h1><h2 id="目标App与AccessibilityManagerService的通讯"><a href="#目标App与AccessibilityManagerService的通讯" class="headerlink" title="目标App与AccessibilityManagerService的通讯"></a>目标App与AccessibilityManagerService的通讯</h2><p>其实目标App与AccessibilityManagerService之间除了在发送AccessibilityEvent时进行了通讯外，在第一次连接获取辅助服务开关状态以及开关状态发生变化时都会进行通讯。判断辅助服务是否开启的逻辑如下：</p><pre><code>public boolean isEnabled() {    synchronized (mLock) {        IAccessibilityManager service = getServiceLocked();        if (service == null) {            return false;        }        return mIsEnabled;    }}private  IAccessibilityManager getServiceLocked() {    if (mService == null) {        tryConnectToServiceLocked(null);    }    return mService;}private void tryConnectToServiceLocked(IAccessibilityManager service) {    if (service == null) {        IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE);        if (iBinder == null) {            return;        }        service = IAccessibilityManager.Stub.asInterface(iBinder);    }    try {        // 向AccessibilityManagerService添加client时会返回当前开关状态        final int stateFlags = service.addClient(mClient, mUserId);        setStateLocked(stateFlags);        mService = service;    } catch (RemoteException re) {        Log.e(LOG_TAG, &quot;AccessibilityManagerService is dead&quot;, re);    }}</code></pre><p>AccessibilityManager中用mIsEnabled变量标识当前辅助功能是否开启，如果当前已经和AccessibilityManagerService建立了联系则直接返回该标识，如果没有会尝试和AccessibilityManagerService联系，调用AccessibilityManagerService.addClient(mClient, mUserId)方法就能得到当前辅助功能的开关状态，之后通过setStateLocked(stateFlags)给mIsEnabled变量赋值。</p><pre><code>private void setStateLocked(int stateFlags) {    final boolean enabled = (stateFlags &amp; STATE_FLAG_ACCESSIBILITY_ENABLED) != 0;    final boolean touchExplorationEnabled =            (stateFlags &amp; STATE_FLAG_TOUCH_EXPLORATION_ENABLED) != 0;    final boolean highTextContrastEnabled =            (stateFlags &amp; STATE_FLAG_HIGH_TEXT_CONTRAST_ENABLED) != 0;    final boolean wasEnabled = mIsEnabled;    final boolean wasTouchExplorationEnabled = mIsTouchExplorationEnabled;    final boolean wasHighTextContrastEnabled = mIsHighTextContrastEnabled;    // Ensure listeners get current state from isZzzEnabled() calls.    mIsEnabled = enabled;    mIsTouchExplorationEnabled = touchExplorationEnabled;    mIsHighTextContrastEnabled = highTextContrastEnabled;    if (wasEnabled != enabled) {        mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_ACCESSIBILITY_STATE_CHANGED);    }    if (wasTouchExplorationEnabled != touchExplorationEnabled) {        mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_EXPLORATION_STATE_CHANGED);    }    if (wasHighTextContrastEnabled != highTextContrastEnabled) {        mHandler.sendEmptyMessage(MyHandler.MSG_NOTIFY_HIGH_TEXT_CONTRAST_STATE_CHANGED);    }}</code></pre><p>除此之外还可以看到我们可以向AccessibilityManager注册一些AccessibilityStateChangeListener，当开关状态发生变化时我们能拿到相应的回调。</p><p>在调用AccessibilityManagerService.addClient(mClient, mUserId)时，目标App就向AccessibilityManagerService注册了自己，mClient代码如下：</p><pre><code>private final IAccessibilityManagerClient.Stub mClient =        new IAccessibilityManagerClient.Stub() {    public void setState(int state) {        mHandler.obtainMessage(MyHandler.MSG_SET_STATE, state, 0).sendToTarget();    }};</code></pre><p>当辅助功能开关变化时，AccessibilityManagerService会调用每个client的setState(int state)方法，通过Handler又调用了setStateLocked(state)方法修改了开关状态。</p><h2 id="第7步AccessibilityManagerService进行了哪些检查和准备"><a href="#第7步AccessibilityManagerService进行了哪些检查和准备" class="headerlink" title="第7步AccessibilityManagerService进行了哪些检查和准备"></a>第7步AccessibilityManagerService进行了哪些检查和准备</h2><p>系统不允许后台用户发送AccessibilityEvent，所以首先会检查处理后的UserId是否和当前UserId一样。实际使用中，多用户的情况并不多，所以我们基本无需考虑UserId的问题。</p><pre><code>public int resolveCallingUserIdEnforcingPermissionsLocked(int userId) {        final int callingUid = Binder.getCallingUid();        if (callingUid == 0                || callingUid == Process.SYSTEM_UID                || callingUid == Process.SHELL_UID) {            if (userId == UserHandle.USER_CURRENT                    || userId == UserHandle.USER_CURRENT_OR_SELF) {                return mCurrentUserId;            }            return resolveProfileParentLocked(userId);        }        final int callingUserId = UserHandle.getUserId(callingUid);        if (callingUserId == userId) {            return resolveProfileParentLocked(userId);        }        final int callingUserParentId = resolveProfileParentLocked(callingUserId);        if (callingUserParentId == mCurrentUserId &amp;&amp;                (userId == UserHandle.USER_CURRENT                        || userId == UserHandle.USER_CURRENT_OR_SELF)) {            return mCurrentUserId;        }        if (!hasPermission(Manifest.permission.INTERACT_ACROSS_USERS)                &amp;&amp; !hasPermission(Manifest.permission.INTERACT_ACROSS_USERS_FULL)) {            throw new SecurityException(&quot;Call from user &quot; + callingUserId + &quot; as user &quot;                    + userId + &quot; without permission INTERACT_ACROSS_USERS or &quot;                    + &quot;INTERACT_ACROSS_USERS_FULL not allowed.&quot;);        }        if (userId == UserHandle.USER_CURRENT                || userId == UserHandle.USER_CURRENT_OR_SELF) {            return mCurrentUserId;        }        throw new IllegalArgumentException(&quot;Calling user can be changed to only &quot;                + &quot;UserHandle.USER_CURRENT or UserHandle.USER_CURRENT_OR_SELF.&quot;);    }private int resolveProfileParentLocked(int userId) {        if (userId != mCurrentUserId) {            final long identity = Binder.clearCallingIdentity();            try {                UserInfo parent = mUserManager.getProfileParent(userId);                if (parent != null) {                    return parent.getUserHandle().getIdentifier();                }            } finally {                Binder.restoreCallingIdentity(identity);            }        }        return userId;    }</code></pre><p>之后会检查这个AccessibilityEvent能不能分发，见下面的代码，一部分EventType是必定可以分发的，其他的EventType会再检查Window的情况。</p><pre><code>private boolean canDispatchAccessibilityEventLocked(AccessibilityEvent event) {        final int eventType = event.getEventType();        switch (eventType) {            case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:            case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:            case AccessibilityEvent.TYPE_ANNOUNCEMENT:            case AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_START:            case AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_END:            case AccessibilityEvent.TYPE_GESTURE_DETECTION_START:            case AccessibilityEvent.TYPE_GESTURE_DETECTION_END:            case AccessibilityEvent.TYPE_TOUCH_INTERACTION_START:            case AccessibilityEvent.TYPE_TOUCH_INTERACTION_END:            case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:            case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:            case AccessibilityEvent.TYPE_ASSIST_READING_CONTEXT:            case AccessibilityEvent.TYPE_WINDOWS_CHANGED: {                return true;            }            default: {                return isRetrievalAllowingWindow(event.getWindowId());            }        }    }private boolean isRetrievalAllowingWindow(int windowId) {        // The system gets to interact with any window it wants.        if (Binder.getCallingUid() == Process.SYSTEM_UID) {            return true;        }        if (windowId == mActiveWindowId) {            return true;        }        return findWindowById(windowId) != null;    }</code></pre><p>这2项检查通过之后，就准备分发事件了，updateActiveAndAccessibilityFocusedWindowLocked方法主要更新了一些跟Window相关的东西，而updateEventSourceLocked方法则是会把不在RETRIEVAL_ALLOWING_EVENT_TYPES之中的AccessibilityEvent的source置为null。</p><pre><code>private static final int RETRIEVAL_ALLOWING_EVENT_TYPES =        AccessibilityEvent.TYPE_VIEW_CLICKED        | AccessibilityEvent.TYPE_VIEW_FOCUSED        | AccessibilityEvent.TYPE_VIEW_HOVER_ENTER        | AccessibilityEvent.TYPE_VIEW_HOVER_EXIT        | AccessibilityEvent.TYPE_VIEW_LONG_CLICKED        | AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED        | AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED        | AccessibilityEvent.TYPE_VIEW_SELECTED        | AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED        | AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED        | AccessibilityEvent.TYPE_VIEW_SCROLLED        | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED        | AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED        | AccessibilityEvent.TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前关于辅助功能的使用的文章很多，但鲜有分析其具体实现的，本文基于Andoird 7.1.0_r7源码分析一下辅助事件是怎么分发的，只涉及事件的分发和辅助App的接收，之后有机会再讲一讲获取AccessibilityNodeInfo、进行操作等等的源码流程。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.darkness463.top/tags/Android/"/>
    
      <category term="Accessibility" scheme="https://blog.darkness463.top/tags/Accessibility/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Java虚拟机(一)-GC</title>
    <link href="https://blog.darkness463.top/2017/03/30/Java-VM-GC/"/>
    <id>https://blog.darkness463.top/2017/03/30/Java-VM-GC/</id>
    <published>2017-03-30T07:00:00.000Z</published>
    <updated>2018-03-27T15:30:04.527Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前看《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书时，做了一些笔记，分享一下，还有几篇会陆续发上来。文中的东西基本都来自书中。</p><a id="more"></a><ul><li><p>判断对象是否存活</p><ul><li><p>引用计数算法（Reference Counting）</p><blockquote><p>给对象中添加一个引用计数器，当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是还不可能再被使用的。实现简单，判定效率高，但很难解决对象之间相互循环引用的问题。</p></blockquote></li><li><p>可达性分析算法（Reachability Analysis）</p><blockquote><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链项链时，则证明此对象是不可用的。</p></blockquote></li><li><p>Java中可作为GC Roots的对象包括下面几种：</p><blockquote><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ol></blockquote></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/03/30/Java-VM-GC/ReachabilityAnalysis.png" alt="可达性分析" title="">                </div>                <div class="image-caption">可达性分析</div>            </figure><ul><li><p>Java中引用关系</p><ul><li><p>强引用（Strong Reference）</p><blockquote><p>类似Object obj = new Object()的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></blockquote></li><li><p>软引用（Soft Reference）</p><blockquote><p>用来描述一些还有用但非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。</p></blockquote></li><li><p>弱引用（Weak Reference）</p><blockquote><p>用来描述非必需对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</p></blockquote></li><li><p>虚引用（Phantom Reference）</p><blockquote><p>也称幽灵引用或幻影引用，最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></blockquote></li></ul></li></ul><ul><li><p>finalize方法</p><blockquote><p>当对象进行可达性分析后发现没有与GC Roots相连接的引用链，将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，则视为“没有必要执行”。【因此finalize()方法只会被执行一次】</p><p>执行finalize()方法时，会将该对象放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行（触发finalize()方法但不承诺会等待它运行结束，防止finalize()方法执行缓慢导致阻塞）。稍后GC会对F-Queue中的对象进行二次标记，如果对象在finalize()方法中使自己与任一对象建立关联，将被移除出“即将回收”的集合，否则将真正回收。但注意finalize()方法只会执行一次。</p><p>不推荐使用。</p></blockquote></li></ul><ul><li><p>垃圾收集算法</p><ul><li><p>标记-清除（Mark-Sweep）算法</p><blockquote><p>先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>不足： </p><ol><li>效率问题，标记和清除两个过程的效率都不高； </li><li>空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol></blockquote></li><li><p>复制（Copying）算法</p><blockquote><p>将内存划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>为减少内存的浪费，实际按8：1：1的比例分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，然后清理掉Eden和刚才用过的Survivor空间。当另一块Survivor空间不足存放Eden和Survivor中存活的对象时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。</p></blockquote></li><li><p>标记-整理（Mark-Compact）算法</p><blockquote><p>标记过程仍然与“标记-清除”算法一样，但不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>老年代一般采用该种算法。</p></blockquote></li><li><p>分代收集（Generational Collection）算法</p><blockquote><p>当前商用虚拟机的垃圾收集都采用分代收集算法。一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p></blockquote></li></ul></li></ul><ul><li><p>垃圾收集器</p><ul><li><p>Serial收集器</p><blockquote><p>单线程的收集器，进行垃圾收集时，必须暂停其他所以的工作线程，直到它收集结束（Stop The World）。复制算法。</p></blockquote></li><li><p>ParNew收集器</p><blockquote><p>Serial收集器的多线程版本，除使用多条线程进行垃圾收集外其余与Serial收集器一样。复制算法。</p></blockquote></li><li><p>Parallel Scavenge收集器</p><blockquote><p>复制算法，并行的多线程收集器。“吞吐量优先”，达到一个可控制的吞吐量（Throughput），吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p></blockquote></li><li><p>Serial Old收集器</p><blockquote><p>单线程，“标记-整理”算法。</p></blockquote></li><li><p>Parallel Old收集器</p><blockquote><p>多线程，“标记-整理”算法。</p></blockquote></li><li><p>CMS收集器（Concurrent Mark Sweep）</p><blockquote><p>以获取最短回收停顿时间为目标的收集器。“标记-清除”算法。整个过程分为4个步骤，耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。</p><ol><li><p>初始标记（CMS initial mark）</p><p> 需stop the world，仅仅标记一下GC Roots能直接关联到的对象，速度很快。</p></li><li><p>并发标记（CMS concurrent mark）</p><p> 进行GC Roots Tracing。</p></li><li><p>重新标记（CMS remark）</p><p> 需stop the world，修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。</p></li><li>并发清除（CMS concurrent sweep）</li></ol></blockquote></li><li><p>G1收集器（Garbage-First）</p><blockquote><p>特点：并行、并发、分代收集、整体“标记-整理”局部（两个Region之间）“复制”算法、可预测的停顿。将整个Java堆划分为多个大小相等的独立区域（Region），跟着各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。步骤：初始标记（Initial Marking）、并发标记（Concurrent Marking）、最终标记（Final Marking）、筛选回收（Live Data Counting and Evacuation）</p></blockquote></li></ul></li></ul><ul><li><p>内存分配与回收策略</p><ul><li><p>对象优先在Eden分配</p><blockquote><p>大多数情况下，对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p></blockquote></li><li><p>大对象直接进入老年代</p><blockquote><p>大对象即需要大量连续内存空间的Java对象，如很长的字符串和数组。</p></blockquote></li><li><p>长期存活的对象将进入老年代</p><blockquote><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），将会被晋升到老年代中。</p></blockquote></li><li><p>动态对象年龄判断</p><blockquote><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到设置要求的年龄。</p></blockquote></li><li><p>空间分配担保</p><blockquote><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，如果小于，或者HandlePromotionFailure设置不允许冒险，则改为进行一次Full GC。</p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久以前看《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书时，做了一些笔记，分享一下，还有几篇会陆续发上来。文中的东西基本都来自书中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.darkness463.top/tags/Java/"/>
    
      <category term="GC" scheme="https://blog.darkness463.top/tags/GC/"/>
    
  </entry>
  
</feed>
